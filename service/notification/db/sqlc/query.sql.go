// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const deleteNotification = `-- name: DeleteNotification :exec
UPDATE notification.notifications
SET is_deleted = true
WHERE id = $1
`

func (q *Queries) DeleteNotification(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteNotification, id)
	return err
}

const getNotifications = `-- name: GetNotifications :many
SELECT id, company_id, branch_id, title, content, type, created_at
FROM notification.notifications
WHERE 
    company_id = $1
    AND branch_id LIKE $2
    AND CASE WHEN $4::bool
    THEN is_read = $3 ELSE TRUE END
    AND is_deleted = false
ORDER BY created_at DESC
`

type GetNotificationsParams struct {
	CompanyID    string `db:"company_id"`
	BranchID     string `db:"branch_id"`
	IsRead       bool   `db:"is_read"`
	IsReadFilter bool   `db:"is_read_filter"`
}

type GetNotificationsRow struct {
	ID        string       `db:"id"`
	CompanyID string       `db:"company_id"`
	BranchID  string       `db:"branch_id"`
	Title     string       `db:"title"`
	Content   string       `db:"content"`
	Type      string       `db:"type"`
	CreatedAt sql.NullTime `db:"created_at"`
}

func (q *Queries) GetNotifications(ctx context.Context, arg GetNotificationsParams) ([]GetNotificationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getNotifications,
		arg.CompanyID,
		arg.BranchID,
		arg.IsRead,
		arg.IsReadFilter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsRow
	for rows.Next() {
		var i GetNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.BranchID,
			&i.Title,
			&i.Content,
			&i.Type,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertNotification = `-- name: InsertNotification :one
INSERT INTO notification.notifications(id, company_id, branch_id, title, content, type)
VALUES ($1, $2, $3, $4, $5, $6) 
RETURNING id, company_id, branch_id, title, content, type, is_read, is_deleted, created_at
`

type InsertNotificationParams struct {
	ID        string `db:"id"`
	CompanyID string `db:"company_id"`
	BranchID  string `db:"branch_id"`
	Title     string `db:"title"`
	Content   string `db:"content"`
	Type      string `db:"type"`
}

func (q *Queries) InsertNotification(ctx context.Context, arg InsertNotificationParams) (NotificationNotification, error) {
	row := q.db.QueryRowContext(ctx, insertNotification,
		arg.ID,
		arg.CompanyID,
		arg.BranchID,
		arg.Title,
		arg.Content,
		arg.Type,
	)
	var i NotificationNotification
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.BranchID,
		&i.Title,
		&i.Content,
		&i.Type,
		&i.IsRead,
		&i.IsDeleted,
		&i.CreatedAt,
	)
	return i, err
}

const readNotification = `-- name: ReadNotification :exec
UPDATE notification.notifications
SET is_read = true
WHERE id = $1
`

func (q *Queries) ReadNotification(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, readNotification, id)
	return err
}
