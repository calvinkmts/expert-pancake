// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const deletePOS = `-- name: DeletePOS :exec
UPDATE sales.point_of_sales SET is_deleted = TRUE WHERE id = $1
`

func (q *Queries) DeletePOS(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePOS, id)
	return err
}

const deletePOSItemsPOS = `-- name: DeletePOSItemsPOS :exec
DELETE FROM sales.point_of_sale_items WHERE point_of_sale_id = $1
`

func (q *Queries) DeletePOSItemsPOS(ctx context.Context, pointOfSaleID string) error {
	_, err := q.db.ExecContext(ctx, deletePOSItemsPOS, pointOfSaleID)
	return err
}

const insertPOSItem = `-- name: InsertPOSItem :one
INSERT INTO sales.point_of_sale_items(
  id, point_of_sale_id, warehouse_rack_id, item_variant_id, item_unit_id, item_unit_value, batch, expired_date, item_barcode_id, amount, price, updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, point_of_sale_id, warehouse_rack_id, item_variant_id, item_unit_id, item_unit_value, batch, expired_date, item_barcode_id, amount, price, is_deleted, created_at, updated_at
`

type InsertPOSItemParams struct {
	ID              string         `db:"id"`
	PointOfSaleID   string         `db:"point_of_sale_id"`
	WarehouseRackID string         `db:"warehouse_rack_id"`
	ItemVariantID   string         `db:"item_variant_id"`
	ItemUnitID      string         `db:"item_unit_id"`
	ItemUnitValue   int64          `db:"item_unit_value"`
	Batch           sql.NullString `db:"batch"`
	ExpiredDate     sql.NullTime   `db:"expired_date"`
	ItemBarcodeID   string         `db:"item_barcode_id"`
	Amount          int64          `db:"amount"`
	Price           int64          `db:"price"`
	UpdatedAt       sql.NullTime   `db:"updated_at"`
}

func (q *Queries) InsertPOSItem(ctx context.Context, arg InsertPOSItemParams) (SalesPointOfSaleItem, error) {
	row := q.db.QueryRowContext(ctx, insertPOSItem,
		arg.ID,
		arg.PointOfSaleID,
		arg.WarehouseRackID,
		arg.ItemVariantID,
		arg.ItemUnitID,
		arg.ItemUnitValue,
		arg.Batch,
		arg.ExpiredDate,
		arg.ItemBarcodeID,
		arg.Amount,
		arg.Price,
		arg.UpdatedAt,
	)
	var i SalesPointOfSaleItem
	err := row.Scan(
		&i.ID,
		&i.PointOfSaleID,
		&i.WarehouseRackID,
		&i.ItemVariantID,
		&i.ItemUnitID,
		&i.ItemUnitValue,
		&i.Batch,
		&i.ExpiredDate,
		&i.ItemBarcodeID,
		&i.Amount,
		&i.Price,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertPOS = `-- name: UpsertPOS :one
INSERT INTO sales.point_of_sales(
  id, company_id, branch_id, warehouse_id, form_number, transaction_date,
  contact_book_id, secondary_company_id, konekin_id, currency_code, chart_of_account_id, total_items, total, updated_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) ON CONFLICT (id) DO
UPDATE
SET company_id = EXCLUDED.company_id,
    branch_id = EXCLUDED.branch_id,
    warehouse_id = EXCLUDED.warehouse_id,
    form_number = EXCLUDED.form_number,
    transaction_date = EXCLUDED.transaction_date,
    contact_book_id = EXCLUDED.contact_book_id,
    secondary_company_id = EXCLUDED.secondary_company_id,
    konekin_id = EXCLUDED.konekin_id,
    currency_code = EXCLUDED.currency_code,
    chart_of_account_id = EXCLUDED.chart_of_account_id,
    total_items = EXCLUDED.total_items,
    total = EXCLUDED.total,
    updated_at = NOW()
RETURNING id, company_id, branch_id, warehouse_id, form_number, transaction_date, contact_book_id, secondary_company_id, konekin_id, currency_code, chart_of_account_id, total_items, total, is_deleted, created_at, updated_at
`

type UpsertPOSParams struct {
	ID                 string       `db:"id"`
	CompanyID          string       `db:"company_id"`
	BranchID           string       `db:"branch_id"`
	WarehouseID        string       `db:"warehouse_id"`
	FormNumber         string       `db:"form_number"`
	TransactionDate    time.Time    `db:"transaction_date"`
	ContactBookID      string       `db:"contact_book_id"`
	SecondaryCompanyID string       `db:"secondary_company_id"`
	KonekinID          string       `db:"konekin_id"`
	CurrencyCode       string       `db:"currency_code"`
	ChartOfAccountID   string       `db:"chart_of_account_id"`
	TotalItems         int64        `db:"total_items"`
	Total              int64        `db:"total"`
	UpdatedAt          sql.NullTime `db:"updated_at"`
}

func (q *Queries) UpsertPOS(ctx context.Context, arg UpsertPOSParams) (SalesPointOfSale, error) {
	row := q.db.QueryRowContext(ctx, upsertPOS,
		arg.ID,
		arg.CompanyID,
		arg.BranchID,
		arg.WarehouseID,
		arg.FormNumber,
		arg.TransactionDate,
		arg.ContactBookID,
		arg.SecondaryCompanyID,
		arg.KonekinID,
		arg.CurrencyCode,
		arg.ChartOfAccountID,
		arg.TotalItems,
		arg.Total,
		arg.UpdatedAt,
	)
	var i SalesPointOfSale
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.BranchID,
		&i.WarehouseID,
		&i.FormNumber,
		&i.TransactionDate,
		&i.ContactBookID,
		&i.SecondaryCompanyID,
		&i.KonekinID,
		&i.CurrencyCode,
		&i.ChartOfAccountID,
		&i.TotalItems,
		&i.Total,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
