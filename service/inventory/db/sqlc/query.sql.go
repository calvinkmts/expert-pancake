// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const deleteBrand = `-- name: DeleteBrand :exec
UPDATE inventory.brands
SET is_deleted = TRUE,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteBrand(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteBrand, id)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
UPDATE inventory.groups
SET is_deleted = TRUE,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, id)
	return err
}

const deleteItemUnit = `-- name: DeleteItemUnit :exec
UPDATE inventory.item_units
SET is_deleted = TRUE,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteItemUnit(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteItemUnit, id)
	return err
}

const deleteItemVariant = `-- name: DeleteItemVariant :exec
UPDATE inventory.item_variants
SET is_deleted = TRUE,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteItemVariant(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteItemVariant, id)
	return err
}

const deleteStockMovement = `-- name: DeleteStockMovement :exec
DELETE FROM inventory.stock_movements
WHERE transaction_id = $1 AND transaction_reference = $2
`

type DeleteStockMovementParams struct {
	TransactionID        string `db:"transaction_id"`
	TransactionReference string `db:"transaction_reference"`
}

func (q *Queries) DeleteStockMovement(ctx context.Context, arg DeleteStockMovementParams) error {
	_, err := q.db.ExecContext(ctx, deleteStockMovement, arg.TransactionID, arg.TransactionReference)
	return err
}

const getBrandById = `-- name: GetBrandById :one
SELECT id,
    company_id,
    name
FROM inventory.brands
WHERE id = $1
`

type GetBrandByIdRow struct {
	ID        string `db:"id"`
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

func (q *Queries) GetBrandById(ctx context.Context, id string) (GetBrandByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getBrandById, id)
	var i GetBrandByIdRow
	err := row.Scan(&i.ID, &i.CompanyID, &i.Name)
	return i, err
}

const getBrands = `-- name: GetBrands :many
SELECT id,
    company_id,
    name
FROM inventory.brands
WHERE company_id = $1
    AND name LIKE $2
    AND is_deleted = false
`

type GetBrandsParams struct {
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

type GetBrandsRow struct {
	ID        string `db:"id"`
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

func (q *Queries) GetBrands(ctx context.Context, arg GetBrandsParams) ([]GetBrandsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBrands, arg.CompanyID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBrandsRow
	for rows.Next() {
		var i GetBrandsRow
		if err := rows.Scan(&i.ID, &i.CompanyID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCheckStockHistory = `-- name: GetCheckStockHistory :one
SELECT COUNT(a.id)::bigint AS total_count
FROM inventory.update_stocks a
WHERE warehouse_id = ANY($1::text [])
`

func (q *Queries) GetCheckStockHistory(ctx context.Context, warehouseIds []string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCheckStockHistory, pq.Array(warehouseIds))
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getGroupById = `-- name: GetGroupById :one
SELECT id,
    company_id,
    name
FROM inventory.groups
WHERE id = $1
`

type GetGroupByIdRow struct {
	ID        string `db:"id"`
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

func (q *Queries) GetGroupById(ctx context.Context, id string) (GetGroupByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupById, id)
	var i GetGroupByIdRow
	err := row.Scan(&i.ID, &i.CompanyID, &i.Name)
	return i, err
}

const getGroups = `-- name: GetGroups :many
SELECT id,
    company_id,
    name
FROM inventory.groups
WHERE company_id = $1
    AND name LIKE $2
    AND is_deleted = false
`

type GetGroupsParams struct {
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

type GetGroupsRow struct {
	ID        string `db:"id"`
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

func (q *Queries) GetGroups(ctx context.Context, arg GetGroupsParams) ([]GetGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroups, arg.CompanyID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsRow
	for rows.Next() {
		var i GetGroupsRow
		if err := rows.Scan(&i.ID, &i.CompanyID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIncomingStock = `-- name: GetIncomingStock :many
SELECT 
	rp.transaction_code as transaction_code,
	c.id as item_id,
	C.code AS item_code,
	C.NAME AS item_name,
	bb.id as variant_id,
	bb.NAME AS variant_name,
    e.id as unit_id,
	e.name as unit_name,
	(rp.amount) AS amount
FROM
	inventory.stock_movements rp
	JOIN inventory.item_variants bb ON bb.ID = rp.variant_id
	JOIN inventory.items C ON bb.item_id = C.ID
    JOIN inventory.item_units d ON d.item_id = c.id
	JOIN inventory.units e ON e.id = d.unit_id AND d.value = 1
WHERE rp.created_at <= NOW() AND rp.amount > 0
ORDER BY rp.created_at DESC
`

type GetIncomingStockRow struct {
	TransactionCode string `db:"transaction_code"`
	ItemID          string `db:"item_id"`
	ItemCode        string `db:"item_code"`
	ItemName        string `db:"item_name"`
	VariantID       string `db:"variant_id"`
	VariantName     string `db:"variant_name"`
	UnitID          string `db:"unit_id"`
	UnitName        string `db:"unit_name"`
	Amount          int64  `db:"amount"`
}

func (q *Queries) GetIncomingStock(ctx context.Context) ([]GetIncomingStockRow, error) {
	rows, err := q.db.QueryContext(ctx, getIncomingStock)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIncomingStockRow
	for rows.Next() {
		var i GetIncomingStockRow
		if err := rows.Scan(
			&i.TransactionCode,
			&i.ItemID,
			&i.ItemCode,
			&i.ItemName,
			&i.VariantID,
			&i.VariantName,
			&i.UnitID,
			&i.UnitName,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInternalStockTransferItems = `-- name: GetInternalStockTransferItems :many
SELECT a.id,
    a.warehouse_rack_id,
    e.name AS item_name,
    a.variant_id,
    b.name AS variant_name,
    a.item_unit_id,
    d.name AS item_unit_name,
    a.item_unit_value,
    a.amount,
    a.batch,
    a.expired_date
FROM inventory.internal_stock_transfer_items a
    JOIN inventory.item_variants b ON a.variant_id = b.id
    JOIN inventory.item_units c ON a.item_unit_id = c.id
    JOIN inventory.units d ON c.unit_id = d.id
    JOIN inventory.items e ON b.item_id = e.id
WHERE a.internal_stock_transfer_id = $1
    AND a.is_deleted = false
`

type GetInternalStockTransferItemsRow struct {
	ID              string         `db:"id"`
	WarehouseRackID string         `db:"warehouse_rack_id"`
	ItemName        string         `db:"item_name"`
	VariantID       string         `db:"variant_id"`
	VariantName     string         `db:"variant_name"`
	ItemUnitID      string         `db:"item_unit_id"`
	ItemUnitName    string         `db:"item_unit_name"`
	ItemUnitValue   int64          `db:"item_unit_value"`
	Amount          int64          `db:"amount"`
	Batch           sql.NullString `db:"batch"`
	ExpiredDate     sql.NullTime   `db:"expired_date"`
}

func (q *Queries) GetInternalStockTransferItems(ctx context.Context, internalStockTransferID string) ([]GetInternalStockTransferItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getInternalStockTransferItems, internalStockTransferID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInternalStockTransferItemsRow
	for rows.Next() {
		var i GetInternalStockTransferItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.WarehouseRackID,
			&i.ItemName,
			&i.VariantID,
			&i.VariantName,
			&i.ItemUnitID,
			&i.ItemUnitName,
			&i.ItemUnitValue,
			&i.Amount,
			&i.Batch,
			&i.ExpiredDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInternalStockTransfers = `-- name: GetInternalStockTransfers :many
SELECT id,
    source_warehouse_id,
    destination_warehouse_id,
    form_number,
    transaction_date
FROM inventory.internal_stock_transfers
WHERE is_deleted = false
    AND transaction_date BETWEEN $1::date AND $2::date
    AND (
        source_warehouse_id = ANY($3::text [])
        OR destination_warehouse_id = ANY($3::text [])
    )
`

type GetInternalStockTransfersParams struct {
	StartDate    time.Time `db:"start_date"`
	EndDate      time.Time `db:"end_date"`
	WarehouseIds []string  `db:"warehouse_ids"`
}

type GetInternalStockTransfersRow struct {
	ID                     string    `db:"id"`
	SourceWarehouseID      string    `db:"source_warehouse_id"`
	DestinationWarehouseID string    `db:"destination_warehouse_id"`
	FormNumber             string    `db:"form_number"`
	TransactionDate        time.Time `db:"transaction_date"`
}

func (q *Queries) GetInternalStockTransfers(ctx context.Context, arg GetInternalStockTransfersParams) ([]GetInternalStockTransfersRow, error) {
	rows, err := q.db.QueryContext(ctx, getInternalStockTransfers, arg.StartDate, arg.EndDate, pq.Array(arg.WarehouseIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInternalStockTransfersRow
	for rows.Next() {
		var i GetInternalStockTransfersRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceWarehouseID,
			&i.DestinationWarehouseID,
			&i.FormNumber,
			&i.TransactionDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemBarcode = `-- name: GetItemBarcode :one
SELECT id
FROM inventory.item_barcodes
WHERE variant_id = $1
    AND CASE
        WHEN $4::bool THEN batch is null
        ELSE batch = $2
    END
    AND CASE
        WHEN $5::bool THEN expired_date is null
        ELSE expired_date = $3
    END
`

type GetItemBarcodeParams struct {
	VariantID         string         `db:"variant_id"`
	Batch             sql.NullString `db:"batch"`
	ExpiredDate       sql.NullTime   `db:"expired_date"`
	IsNullBatch       bool           `db:"is_null_batch"`
	IsNullExpiredDate bool           `db:"is_null_expired_date"`
}

func (q *Queries) GetItemBarcode(ctx context.Context, arg GetItemBarcodeParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getItemBarcode,
		arg.VariantID,
		arg.Batch,
		arg.ExpiredDate,
		arg.IsNullBatch,
		arg.IsNullExpiredDate,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getItemGroups = `-- name: GetItemGroups :one
SELECT string_agg(CONCAT(id, '|', name), ',')::text AS groups
FROM inventory.groups
WHERE is_deleted = false
AND id = ANY($1::text [])
`

func (q *Queries) GetItemGroups(ctx context.Context, groupIds []string) (string, error) {
	row := q.db.QueryRowContext(ctx, getItemGroups, pq.Array(groupIds))
	var groups string
	err := row.Scan(&groups)
	return groups, err
}

const getItemInfo = `-- name: GetItemInfo :one
SELECT a.item_id,
    d.company_id,
    a.is_purchase,
    a.is_sale,
    a.is_raw_material,
    a.is_asset,
    a.purchase_chart_of_account_id,
    a.sale_chart_of_account_id,
    a.purchase_item_unit_id,
    c.name AS purchase_item_unit_name
FROM inventory.item_infos a
    JOIN inventory.item_units b ON a.purchase_item_unit_id = b.id
    JOIN inventory.units c ON b.unit_id = c.id
    JOIN inventory.items d ON a.item_id = d.id
WHERE a.item_id = $1
`

type GetItemInfoRow struct {
	ItemID                   string `db:"item_id"`
	CompanyID                string `db:"company_id"`
	IsPurchase               bool   `db:"is_purchase"`
	IsSale                   bool   `db:"is_sale"`
	IsRawMaterial            bool   `db:"is_raw_material"`
	IsAsset                  bool   `db:"is_asset"`
	PurchaseChartOfAccountID string `db:"purchase_chart_of_account_id"`
	SaleChartOfAccountID     string `db:"sale_chart_of_account_id"`
	PurchaseItemUnitID       string `db:"purchase_item_unit_id"`
	PurchaseItemUnitName     string `db:"purchase_item_unit_name"`
}

func (q *Queries) GetItemInfo(ctx context.Context, itemID string) (GetItemInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getItemInfo, itemID)
	var i GetItemInfoRow
	err := row.Scan(
		&i.ItemID,
		&i.CompanyID,
		&i.IsPurchase,
		&i.IsSale,
		&i.IsRawMaterial,
		&i.IsAsset,
		&i.PurchaseChartOfAccountID,
		&i.SaleChartOfAccountID,
		&i.PurchaseItemUnitID,
		&i.PurchaseItemUnitName,
	)
	return i, err
}

const getItemReorder = `-- name: GetItemReorder :one
SELECT a.id,
    a.variant_id,
    b.name as variant_name,
    c.id as item_id,
    c.name as item_name,
    d.id as item_unit_id,
    e.name as item_unit_name,
    a.warehouse_id,
    a.minimum_stock
FROM inventory.item_reorders a
    JOIN inventory.item_variants b ON a.variant_id = b.id
    JOIN inventory.items c ON b.item_id = c.id
    JOIN inventory.item_units d ON a.item_unit_id = d.id
    JOIN inventory.units e ON d.unit_id = e.id
WHERE a.id = $1
`

type GetItemReorderRow struct {
	ID           string `db:"id"`
	VariantID    string `db:"variant_id"`
	VariantName  string `db:"variant_name"`
	ItemID       string `db:"item_id"`
	ItemName     string `db:"item_name"`
	ItemUnitID   string `db:"item_unit_id"`
	ItemUnitName string `db:"item_unit_name"`
	WarehouseID  string `db:"warehouse_id"`
	MinimumStock int64  `db:"minimum_stock"`
}

func (q *Queries) GetItemReorder(ctx context.Context, id string) (GetItemReorderRow, error) {
	row := q.db.QueryRowContext(ctx, getItemReorder, id)
	var i GetItemReorderRow
	err := row.Scan(
		&i.ID,
		&i.VariantID,
		&i.VariantName,
		&i.ItemID,
		&i.ItemName,
		&i.ItemUnitID,
		&i.ItemUnitName,
		&i.WarehouseID,
		&i.MinimumStock,
	)
	return i, err
}

const getItemReorderNotifications = `-- name: GetItemReorderNotifications :many
SELECT b.id AS item_id, b.name AS item_name,
a.id AS variant_id, a.name AS variant_name,
COALESCE(SUM(c.amount), 0)::bigint AS current_stock,
d.id AS item_reorder_id,
COALESCE((d.minimum_stock*e.value), 0)::bigint AS minimum_stock
FROM inventory.item_variants a
JOIN inventory.items b ON a.item_id = b.id
LEFT JOIN inventory.stock_movements c ON a.id = c.variant_id
AND c.warehouse_id = $1
LEFT JOIN inventory.item_reorders d ON a.id = d.variant_id
AND d.warehouse_id = $1
LEFT JOIN inventory.item_units e ON b.id = e.item_id
AND d.item_unit_id = e.id
WHERE a.id = ANY($2::text [])
GROUP BY b.id, a.id, d.id, e.value
`

type GetItemReorderNotificationsParams struct {
	WarehouseID    string   `db:"warehouse_id"`
	ItemVariantIds []string `db:"item_variant_ids"`
}

type GetItemReorderNotificationsRow struct {
	ItemID        string         `db:"item_id"`
	ItemName      string         `db:"item_name"`
	VariantID     string         `db:"variant_id"`
	VariantName   string         `db:"variant_name"`
	CurrentStock  int64          `db:"current_stock"`
	ItemReorderID sql.NullString `db:"item_reorder_id"`
	MinimumStock  int64          `db:"minimum_stock"`
}

func (q *Queries) GetItemReorderNotifications(ctx context.Context, arg GetItemReorderNotificationsParams) ([]GetItemReorderNotificationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemReorderNotifications, arg.WarehouseID, pq.Array(arg.ItemVariantIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemReorderNotificationsRow
	for rows.Next() {
		var i GetItemReorderNotificationsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemName,
			&i.VariantID,
			&i.VariantName,
			&i.CurrentStock,
			&i.ItemReorderID,
			&i.MinimumStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemReorders = `-- name: GetItemReorders :many
SELECT a.id,
    a.variant_id,
    b.name as variant_name,
    c.id as item_id,
    c.name as item_name,
    d.id as item_unit_id,
    e.name as item_unit_name,
    a.warehouse_id,
    a.minimum_stock
FROM inventory.item_reorders a
    JOIN inventory.item_variants b ON a.variant_id = b.id
    JOIN inventory.items c ON b.item_id = c.id
    JOIN inventory.item_units d ON a.item_unit_id = d.id
    JOIN inventory.units e ON d.unit_id = e.id
WHERE a.warehouse_id LIKE $1
    AND b.item_id LIKE $2
`

type GetItemReordersParams struct {
	WarehouseID string `db:"warehouse_id"`
	ItemID      string `db:"item_id"`
}

type GetItemReordersRow struct {
	ID           string `db:"id"`
	VariantID    string `db:"variant_id"`
	VariantName  string `db:"variant_name"`
	ItemID       string `db:"item_id"`
	ItemName     string `db:"item_name"`
	ItemUnitID   string `db:"item_unit_id"`
	ItemUnitName string `db:"item_unit_name"`
	WarehouseID  string `db:"warehouse_id"`
	MinimumStock int64  `db:"minimum_stock"`
}

func (q *Queries) GetItemReorders(ctx context.Context, arg GetItemReordersParams) ([]GetItemReordersRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemReorders, arg.WarehouseID, arg.ItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemReordersRow
	for rows.Next() {
		var i GetItemReordersRow
		if err := rows.Scan(
			&i.ID,
			&i.VariantID,
			&i.VariantName,
			&i.ItemID,
			&i.ItemName,
			&i.ItemUnitID,
			&i.ItemUnitName,
			&i.WarehouseID,
			&i.MinimumStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemUnits = `-- name: GetItemUnits :many
SELECT a.id,
    a.item_id,
    a.unit_id,
    b.name AS unit_name,
    a.value,
    a.is_default
FROM inventory.item_units a
    JOIN inventory.units b ON a.unit_id = b.id
WHERE CASE WHEN $4::bool THEN a.id = $1 ELSE a.item_id = $2
    AND b.name LIKE $3
	AND a.is_deleted = false END
`

type GetItemUnitsParams struct {
	ID         string `db:"id"`
	ItemID     string `db:"item_id"`
	Name       string `db:"name"`
	IsFilterID bool   `db:"is_filter_id"`
}

type GetItemUnitsRow struct {
	ID        string `db:"id"`
	ItemID    string `db:"item_id"`
	UnitID    string `db:"unit_id"`
	UnitName  string `db:"unit_name"`
	Value     int64  `db:"value"`
	IsDefault bool   `db:"is_default"`
}

func (q *Queries) GetItemUnits(ctx context.Context, arg GetItemUnitsParams) ([]GetItemUnitsRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemUnits,
		arg.ID,
		arg.ItemID,
		arg.Name,
		arg.IsFilterID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemUnitsRow
	for rows.Next() {
		var i GetItemUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.UnitID,
			&i.UnitName,
			&i.Value,
			&i.IsDefault,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemVariant = `-- name: GetItemVariant :one
SELECT b.id,
    a.id AS variant_id,
    b.company_id,
    a.image_url,
    b.code,
    a.barcode,
    b.name,
    a.name AS variant_name,
    b.brand_id,
    COALESCE(c.name, '') AS brand_name,
    b.group_id,
    string_agg(CONCAT(d.id, '|', d.name), ',')::text AS groups,
    b.tag,
    b.description,
    a.is_default,
    a.price
FROM inventory.item_variants a
    JOIN inventory.items b ON a.item_id = b.id
    LEFT JOIN inventory.brands c ON b.brand_id = c.id
    JOIN inventory.groups d ON d.id = ANY(string_to_array(b.group_id, ','))
WHERE a.id = $1
GROUP BY a.id, b.id, c.id
`

type GetItemVariantRow struct {
	ID          string `db:"id"`
	VariantID   string `db:"variant_id"`
	CompanyID   string `db:"company_id"`
	ImageUrl    string `db:"image_url"`
	Code        string `db:"code"`
	Barcode     string `db:"barcode"`
	Name        string `db:"name"`
	VariantName string `db:"variant_name"`
	BrandID     string `db:"brand_id"`
	BrandName   string `db:"brand_name"`
	GroupID     string `db:"group_id"`
	Groups      string `db:"groups"`
	Tag         string `db:"tag"`
	Description string `db:"description"`
	IsDefault   bool   `db:"is_default"`
	Price       int64  `db:"price"`
}

func (q *Queries) GetItemVariant(ctx context.Context, id string) (GetItemVariantRow, error) {
	row := q.db.QueryRowContext(ctx, getItemVariant, id)
	var i GetItemVariantRow
	err := row.Scan(
		&i.ID,
		&i.VariantID,
		&i.CompanyID,
		&i.ImageUrl,
		&i.Code,
		&i.Barcode,
		&i.Name,
		&i.VariantName,
		&i.BrandID,
		&i.BrandName,
		&i.GroupID,
		&i.Groups,
		&i.Tag,
		&i.Description,
		&i.IsDefault,
		&i.Price,
	)
	return i, err
}

const getItemVariantMap = `-- name: GetItemVariantMap :one
SELECT a.id,

e.id AS primary_item_id, e.name AS primary_item_name,
b.id AS primary_item_variant_id, b.name AS primary_item_variant_name,
b.price AS primary_item_variant_price,
c.id AS primary_item_unit_id, d.name AS primary_item_unit_name,

i.id AS secondary_item_id, i.name AS secondary_item_name,
f.id AS secondary_item_variant_id, f.name AS secondary_item_variant_name,
f.price AS secondary_item_variant_price,
g.id AS secondary_item_unit_id, h.name AS secondary_item_unit_name

FROM inventory.item_variant_maps a

JOIN inventory.item_variants b ON a.primary_item_variant_id = b.id
JOIN inventory.item_units c ON a.primary_item_unit_id = c.id
JOIN inventory.units d ON c.unit_id = d.id
JOIN inventory.items e ON b.item_id = e.id

JOIN inventory.item_variants f ON a.secondary_item_variant_id = f.id
JOIN inventory.item_units g ON a.secondary_item_unit_id = g.id
JOIN inventory.units h ON g.unit_id = h.id
JOIN inventory.items i ON f.item_id = i.id
WHERE a.id = $1
`

type GetItemVariantMapRow struct {
	ID                        string `db:"id"`
	PrimaryItemID             string `db:"primary_item_id"`
	PrimaryItemName           string `db:"primary_item_name"`
	PrimaryItemVariantID      string `db:"primary_item_variant_id"`
	PrimaryItemVariantName    string `db:"primary_item_variant_name"`
	PrimaryItemVariantPrice   int64  `db:"primary_item_variant_price"`
	PrimaryItemUnitID         string `db:"primary_item_unit_id"`
	PrimaryItemUnitName       string `db:"primary_item_unit_name"`
	SecondaryItemID           string `db:"secondary_item_id"`
	SecondaryItemName         string `db:"secondary_item_name"`
	SecondaryItemVariantID    string `db:"secondary_item_variant_id"`
	SecondaryItemVariantName  string `db:"secondary_item_variant_name"`
	SecondaryItemVariantPrice int64  `db:"secondary_item_variant_price"`
	SecondaryItemUnitID       string `db:"secondary_item_unit_id"`
	SecondaryItemUnitName     string `db:"secondary_item_unit_name"`
}

func (q *Queries) GetItemVariantMap(ctx context.Context, id string) (GetItemVariantMapRow, error) {
	row := q.db.QueryRowContext(ctx, getItemVariantMap, id)
	var i GetItemVariantMapRow
	err := row.Scan(
		&i.ID,
		&i.PrimaryItemID,
		&i.PrimaryItemName,
		&i.PrimaryItemVariantID,
		&i.PrimaryItemVariantName,
		&i.PrimaryItemVariantPrice,
		&i.PrimaryItemUnitID,
		&i.PrimaryItemUnitName,
		&i.SecondaryItemID,
		&i.SecondaryItemName,
		&i.SecondaryItemVariantID,
		&i.SecondaryItemVariantName,
		&i.SecondaryItemVariantPrice,
		&i.SecondaryItemUnitID,
		&i.SecondaryItemUnitName,
	)
	return i, err
}

const getItemVariantMaps = `-- name: GetItemVariantMaps :many
SELECT a.id,

e.id AS primary_item_id, e.name AS primary_item_name,
b.id AS primary_item_variant_id, b.name AS primary_item_variant_name,
b.price AS primary_item_variant_price,
c.id AS primary_item_unit_id, d.name AS primary_item_unit_name,

i.id AS secondary_item_id, i.name AS secondary_item_name,
f.id AS secondary_item_variant_id, f.name AS secondary_item_variant_name,
f.price AS secondary_item_variant_price,
g.id AS secondary_item_unit_id, h.name AS secondary_item_unit_name

FROM inventory.item_variant_maps a

JOIN inventory.item_variants b ON a.primary_item_variant_id = b.id
JOIN inventory.item_units c ON a.primary_item_unit_id = c.id
JOIN inventory.units d ON c.unit_id = d.id
JOIN inventory.items e ON b.item_id = e.id

JOIN inventory.item_variants f ON a.secondary_item_variant_id = f.id
JOIN inventory.item_units g ON a.secondary_item_unit_id = g.id
JOIN inventory.units h ON g.unit_id = h.id
JOIN inventory.items i ON f.item_id = i.id
WHERE i.company_id = $1 AND e.id = $2
ORDER BY b.created_at, c.value
`

type GetItemVariantMapsParams struct {
	CompanyID     string `db:"company_id"`
	PrimaryItemID string `db:"primary_item_id"`
}

type GetItemVariantMapsRow struct {
	ID                        string `db:"id"`
	PrimaryItemID             string `db:"primary_item_id"`
	PrimaryItemName           string `db:"primary_item_name"`
	PrimaryItemVariantID      string `db:"primary_item_variant_id"`
	PrimaryItemVariantName    string `db:"primary_item_variant_name"`
	PrimaryItemVariantPrice   int64  `db:"primary_item_variant_price"`
	PrimaryItemUnitID         string `db:"primary_item_unit_id"`
	PrimaryItemUnitName       string `db:"primary_item_unit_name"`
	SecondaryItemID           string `db:"secondary_item_id"`
	SecondaryItemName         string `db:"secondary_item_name"`
	SecondaryItemVariantID    string `db:"secondary_item_variant_id"`
	SecondaryItemVariantName  string `db:"secondary_item_variant_name"`
	SecondaryItemVariantPrice int64  `db:"secondary_item_variant_price"`
	SecondaryItemUnitID       string `db:"secondary_item_unit_id"`
	SecondaryItemUnitName     string `db:"secondary_item_unit_name"`
}

func (q *Queries) GetItemVariantMaps(ctx context.Context, arg GetItemVariantMapsParams) ([]GetItemVariantMapsRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemVariantMaps, arg.CompanyID, arg.PrimaryItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemVariantMapsRow
	for rows.Next() {
		var i GetItemVariantMapsRow
		if err := rows.Scan(
			&i.ID,
			&i.PrimaryItemID,
			&i.PrimaryItemName,
			&i.PrimaryItemVariantID,
			&i.PrimaryItemVariantName,
			&i.PrimaryItemVariantPrice,
			&i.PrimaryItemUnitID,
			&i.PrimaryItemUnitName,
			&i.SecondaryItemID,
			&i.SecondaryItemName,
			&i.SecondaryItemVariantID,
			&i.SecondaryItemVariantName,
			&i.SecondaryItemVariantPrice,
			&i.SecondaryItemUnitID,
			&i.SecondaryItemUnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemVariants = `-- name: GetItemVariants :many
SELECT b.id,
    a.id AS variant_id,
    b.company_id,
    a.image_url,
    b.code,
    a.barcode,
    b.name,
    a.name AS variant_name,
    b.brand_id,
    COALESCE(c.name, '') AS brand_name,
    b.group_id,
    string_agg(CONCAT(d.id, '|', d.name), ',')::text AS groups,
    b.tag,
    b.description,
    a.is_default,
    a.price
FROM inventory.item_variants a
    JOIN inventory.items b ON a.item_id = b.id
    LEFT JOIN inventory.brands c ON b.brand_id = c.id
    JOIN inventory.groups d ON d.id = ANY(string_to_array(b.group_id, ','))
WHERE a.is_deleted = FALSE AND CASE WHEN $4::bool THEN a.id = $1 ELSE a.item_id = $2
    AND a.name LIKE $3 END
GROUP BY a.id, b.id, c.id
`

type GetItemVariantsParams struct {
	ID         string `db:"id"`
	ItemID     string `db:"item_id"`
	Name       string `db:"name"`
	IsFilterID bool   `db:"is_filter_id"`
}

type GetItemVariantsRow struct {
	ID          string `db:"id"`
	VariantID   string `db:"variant_id"`
	CompanyID   string `db:"company_id"`
	ImageUrl    string `db:"image_url"`
	Code        string `db:"code"`
	Barcode     string `db:"barcode"`
	Name        string `db:"name"`
	VariantName string `db:"variant_name"`
	BrandID     string `db:"brand_id"`
	BrandName   string `db:"brand_name"`
	GroupID     string `db:"group_id"`
	Groups      string `db:"groups"`
	Tag         string `db:"tag"`
	Description string `db:"description"`
	IsDefault   bool   `db:"is_default"`
	Price       int64  `db:"price"`
}

func (q *Queries) GetItemVariants(ctx context.Context, arg GetItemVariantsParams) ([]GetItemVariantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemVariants,
		arg.ID,
		arg.ItemID,
		arg.Name,
		arg.IsFilterID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemVariantsRow
	for rows.Next() {
		var i GetItemVariantsRow
		if err := rows.Scan(
			&i.ID,
			&i.VariantID,
			&i.CompanyID,
			&i.ImageUrl,
			&i.Code,
			&i.Barcode,
			&i.Name,
			&i.VariantName,
			&i.BrandID,
			&i.BrandName,
			&i.GroupID,
			&i.Groups,
			&i.Tag,
			&i.Description,
			&i.IsDefault,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItems = `-- name: GetItems :many
SELECT a.id,
    b.id AS variant_id,
    a.company_id,
    b.image_url,
    a.code,
    b.barcode,
    a.name,
    b.name AS variant_name,
    a.brand_id,
    COALESCE(c.name, '') AS brand_name,
    a.group_id,
    string_agg(CONCAT(d.id, '|', d.name), ',')::text AS groups,
    a.tag,
    a.description,
    b.is_default,
    b.price
FROM inventory.items a
    JOIN inventory.item_variants b ON a.id = b.item_id
    LEFT JOIN inventory.brands c ON a.brand_id = c.id
    JOIN inventory.groups d ON d.id = ANY(string_to_array(a.group_id, ','))
WHERE a.company_id = $1
    AND (b.name LIKE $2 OR a.tag LIKE $2)
GROUP BY a.id, b.id, c.id
`

type GetItemsParams struct {
	CompanyID string `db:"company_id"`
	Keyword   string `db:"keyword"`
}

type GetItemsRow struct {
	ID          string `db:"id"`
	VariantID   string `db:"variant_id"`
	CompanyID   string `db:"company_id"`
	ImageUrl    string `db:"image_url"`
	Code        string `db:"code"`
	Barcode     string `db:"barcode"`
	Name        string `db:"name"`
	VariantName string `db:"variant_name"`
	BrandID     string `db:"brand_id"`
	BrandName   string `db:"brand_name"`
	GroupID     string `db:"group_id"`
	Groups      string `db:"groups"`
	Tag         string `db:"tag"`
	Description string `db:"description"`
	IsDefault   bool   `db:"is_default"`
	Price       int64  `db:"price"`
}

func (q *Queries) GetItems(ctx context.Context, arg GetItemsParams) ([]GetItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getItems, arg.CompanyID, arg.Keyword)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsRow
	for rows.Next() {
		var i GetItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.VariantID,
			&i.CompanyID,
			&i.ImageUrl,
			&i.Code,
			&i.Barcode,
			&i.Name,
			&i.VariantName,
			&i.BrandID,
			&i.BrandName,
			&i.GroupID,
			&i.Groups,
			&i.Tag,
			&i.Description,
			&i.IsDefault,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMappingItemUnits = `-- name: GetMappingItemUnits :many
SELECT c.id AS item_unit_id, d.name AS unit_name
FROM inventory.item_variants a
JOIN inventory.items b ON a.item_id = b.id
JOIN inventory.item_units c ON b.id = c.item_id
JOIN inventory.units d ON c.unit_id = d.id
LEFT JOIN inventory.item_variant_maps e ON a.id = 
CASE WHEN $4::bool THEN e.primary_item_variant_id ELSE e.secondary_item_variant_id END
AND c.id =
CASE WHEN $4::bool THEN e.primary_item_unit_id ELSE e.secondary_item_unit_id END
AND CASE WHEN $4::bool THEN e.secondary_company_id = $2 ELSE e.primary_company_id = $3 END
WHERE a.id = $1
AND e.id is null
`

type GetMappingItemUnitsParams struct {
	ID                 string `db:"id"`
	SecondaryCompanyID string `db:"secondary_company_id"`
	PrimaryCompanyID   string `db:"primary_company_id"`
	IsSupplier         bool   `db:"is_supplier"`
}

type GetMappingItemUnitsRow struct {
	ItemUnitID string `db:"item_unit_id"`
	UnitName   string `db:"unit_name"`
}

func (q *Queries) GetMappingItemUnits(ctx context.Context, arg GetMappingItemUnitsParams) ([]GetMappingItemUnitsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMappingItemUnits,
		arg.ID,
		arg.SecondaryCompanyID,
		arg.PrimaryCompanyID,
		arg.IsSupplier,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMappingItemUnitsRow
	for rows.Next() {
		var i GetMappingItemUnitsRow
		if err := rows.Scan(&i.ItemUnitID, &i.UnitName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMappingItemVariants = `-- name: GetMappingItemVariants :many
SELECT b.id,
    a.id AS variant_id,
    b.company_id,
    a.image_url,
    b.code,
    a.barcode,
    b.name,
    a.name AS variant_name,
    b.brand_id,
    COALESCE(c.name, '') AS brand_name,
    a.is_default,
    a.price
FROM inventory.item_variants a
    JOIN inventory.items b ON a.item_id = b.id
    LEFT JOIN inventory.brands c ON b.brand_id = c.id
    LEFT JOIN inventory.item_variant_maps d ON a.id = d.secondary_item_variant_id
    AND d.primary_company_id = $3 AND d.secondary_company_id = $4
WHERE a.item_id = $1
    AND a.name LIKE $2
    AND d.id is null
    AND CASE WHEN a.is_default THEN
    NOT EXISTS (
		SELECT
			1
		FROM
			inventory.item_variants a1
		WHERE
			a1.item_id = a.item_id
            AND a1.is_default is false
	)
    ELSE TRUE END
GROUP BY a.id, b.id, c.id
`

type GetMappingItemVariantsParams struct {
	ItemID             string `db:"item_id"`
	Name               string `db:"name"`
	PrimaryCompanyID   string `db:"primary_company_id"`
	SecondaryCompanyID string `db:"secondary_company_id"`
}

type GetMappingItemVariantsRow struct {
	ID          string `db:"id"`
	VariantID   string `db:"variant_id"`
	CompanyID   string `db:"company_id"`
	ImageUrl    string `db:"image_url"`
	Code        string `db:"code"`
	Barcode     string `db:"barcode"`
	Name        string `db:"name"`
	VariantName string `db:"variant_name"`
	BrandID     string `db:"brand_id"`
	BrandName   string `db:"brand_name"`
	IsDefault   bool   `db:"is_default"`
	Price       int64  `db:"price"`
}

func (q *Queries) GetMappingItemVariants(ctx context.Context, arg GetMappingItemVariantsParams) ([]GetMappingItemVariantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMappingItemVariants,
		arg.ItemID,
		arg.Name,
		arg.PrimaryCompanyID,
		arg.SecondaryCompanyID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMappingItemVariantsRow
	for rows.Next() {
		var i GetMappingItemVariantsRow
		if err := rows.Scan(
			&i.ID,
			&i.VariantID,
			&i.CompanyID,
			&i.ImageUrl,
			&i.Code,
			&i.Barcode,
			&i.Name,
			&i.VariantName,
			&i.BrandID,
			&i.BrandName,
			&i.IsDefault,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMappingItems = `-- name: GetMappingItems :many
SELECT a.id,
    a.code,
    a.name
FROM inventory.items a
WHERE a.company_id = $3
AND a.name LIKE $1
AND NOT EXISTS (
    SELECT
        1
    FROM
        inventory.item_variant_maps a1
    JOIN inventory.item_variants b1 ON a1.secondary_item_variant_id = b1.id
    WHERE
        a1.primary_company_id = $4
        AND a1.secondary_company_id = $3
        AND b1.item_id = a.id
)
UNION ALL
SELECT a.id,
    a.code,
    a.name
FROM inventory.items a
JOIN inventory.item_variants b ON a.id = b.item_id
JOIN inventory.item_variant_maps c ON b.id = c.secondary_item_variant_id
AND c.primary_company_id = $4
JOIN inventory.item_variants d ON c.primary_item_variant_id = d.id
AND d.item_id = $2
WHERE a.company_id = $3
AND a.name LIKE $1
AND EXISTS (
    SELECT
        1
    FROM
        inventory.item_variants a2
    LEFT JOIN inventory.item_variant_maps b2 ON a2.id = b2.secondary_item_variant_id
    AND b2.primary_company_id = $4
    WHERE
        a2.item_id = a.id
        AND b2.id is null
)
`

type GetMappingItemsParams struct {
	Name               string `db:"name"`
	ItemID             string `db:"item_id"`
	SecondaryCompanyID string `db:"secondary_company_id"`
	PrimaryCompanyID   string `db:"primary_company_id"`
}

type GetMappingItemsRow struct {
	ID   string `db:"id"`
	Code string `db:"code"`
	Name string `db:"name"`
}

func (q *Queries) GetMappingItems(ctx context.Context, arg GetMappingItemsParams) ([]GetMappingItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMappingItems,
		arg.Name,
		arg.ItemID,
		arg.SecondaryCompanyID,
		arg.PrimaryCompanyID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMappingItemsRow
	for rows.Next() {
		var i GetMappingItemsRow
		if err := rows.Scan(&i.ID, &i.Code, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutgoingStock = `-- name: GetOutgoingStock :many
SELECT 
	rp.transaction_code as transaction_code,
	c.id as item_id,
	C.code AS item_code,
	C.NAME AS item_name,
	bb.id as variant_id,
	bb.NAME AS variant_name,
    e.id as unit_id,
	e.name as unit_name,
	-(rp.amount) AS amount
FROM
	inventory.stock_movements rp
	JOIN inventory.item_variants bb ON bb.ID = rp.variant_id
	JOIN inventory.items C ON bb.item_id = C.ID
    JOIN inventory.item_units d ON d.item_id = c.id
	JOIN inventory.units e ON e.id = d.unit_id AND d.value = 1
WHERE rp.created_at <= NOW() AND rp.amount < 0
ORDER BY rp.created_at DESC
`

type GetOutgoingStockRow struct {
	TransactionCode string `db:"transaction_code"`
	ItemID          string `db:"item_id"`
	ItemCode        string `db:"item_code"`
	ItemName        string `db:"item_name"`
	VariantID       string `db:"variant_id"`
	VariantName     string `db:"variant_name"`
	UnitID          string `db:"unit_id"`
	UnitName        string `db:"unit_name"`
	Amount          int32  `db:"amount"`
}

func (q *Queries) GetOutgoingStock(ctx context.Context) ([]GetOutgoingStockRow, error) {
	rows, err := q.db.QueryContext(ctx, getOutgoingStock)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOutgoingStockRow
	for rows.Next() {
		var i GetOutgoingStockRow
		if err := rows.Scan(
			&i.TransactionCode,
			&i.ItemID,
			&i.ItemCode,
			&i.ItemName,
			&i.VariantID,
			&i.VariantName,
			&i.UnitID,
			&i.UnitName,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPOSItems = `-- name: GetPOSItems :many
SELECT a.id AS item_id, a.name AS item_name,
b.id AS variant_id, b.name AS variant_name,
c.id AS item_unit_id, d.name AS unit_name,
c.value AS item_unit_value, COALESCE(f.price, 0)::bigint AS price,
SUM(g.amount) AS stock
FROM inventory.items a
JOIN inventory.item_variants b ON a.id = b.item_id
JOIN inventory.item_units c ON b.item_id = c.item_id AND c.value = 1
JOIN inventory.units d ON c.unit_id = d.id
JOIN inventory.pricelists e ON a.company_id = e.company_id
AND e.is_default = true
LEFT JOIN inventory.pricelist_items f ON b.id = f.variant_id
AND c.id = f.item_unit_id AND e.id = f.pricelist_id
JOIN inventory.stock_movements g ON b.id = g.variant_id
AND g.warehouse_id = $2
WHERE a.company_id = $1
AND a.name LIKE $3
AND CASE WHEN b.is_default THEN
NOT EXISTS (
    SELECT
        1
    FROM
        inventory.item_variants a1
    WHERE
        a1.item_id = b.item_id
        AND a1.is_default is false
)
ELSE TRUE END
GROUP BY a.id, b.id, c.id, d.id, f.price
HAVING SUM(g.amount) > 0
ORDER BY a.name, b.name, c.value
`

type GetPOSItemsParams struct {
	CompanyID   string `db:"company_id"`
	WarehouseID string `db:"warehouse_id"`
	Name        string `db:"name"`
}

type GetPOSItemsRow struct {
	ItemID        string `db:"item_id"`
	ItemName      string `db:"item_name"`
	VariantID     string `db:"variant_id"`
	VariantName   string `db:"variant_name"`
	ItemUnitID    string `db:"item_unit_id"`
	UnitName      string `db:"unit_name"`
	ItemUnitValue int64  `db:"item_unit_value"`
	Price         int64  `db:"price"`
	Stock         int64  `db:"stock"`
}

func (q *Queries) GetPOSItems(ctx context.Context, arg GetPOSItemsParams) ([]GetPOSItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPOSItems, arg.CompanyID, arg.WarehouseID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPOSItemsRow
	for rows.Next() {
		var i GetPOSItemsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemName,
			&i.VariantID,
			&i.VariantName,
			&i.ItemUnitID,
			&i.UnitName,
			&i.ItemUnitValue,
			&i.Price,
			&i.Stock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPricelistItems = `-- name: GetPricelistItems :many
SELECT a.id AS item_id, a.name AS item_name,
b.id AS variant_id, b.name AS variant_name,
c.id AS item_unit_id, d.name AS unit_name,
COALESCE(e.price, 0)::bigint AS price
FROM inventory.items a
JOIN inventory.item_variants b ON a.id = b.item_id
JOIN inventory.item_units c ON b.item_id = c.item_id
JOIN inventory.units d ON c.unit_id = d.id
LEFT JOIN inventory.pricelist_items e ON b.id = e.variant_id
AND c.id = e.item_unit_id AND e.pricelist_id = $2
WHERE a.company_id = $1
AND a.name LIKE $3
AND CASE WHEN b.is_default THEN
NOT EXISTS (
    SELECT
        1
    FROM
        inventory.item_variants a1
    WHERE
        a1.item_id = b.item_id
        AND a1.is_default is false
)
ELSE TRUE END
ORDER BY a.name, b.name, c.value
`

type GetPricelistItemsParams struct {
	CompanyID   string `db:"company_id"`
	PricelistID string `db:"pricelist_id"`
	Name        string `db:"name"`
}

type GetPricelistItemsRow struct {
	ItemID      string `db:"item_id"`
	ItemName    string `db:"item_name"`
	VariantID   string `db:"variant_id"`
	VariantName string `db:"variant_name"`
	ItemUnitID  string `db:"item_unit_id"`
	UnitName    string `db:"unit_name"`
	Price       int64  `db:"price"`
}

func (q *Queries) GetPricelistItems(ctx context.Context, arg GetPricelistItemsParams) ([]GetPricelistItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPricelistItems, arg.CompanyID, arg.PricelistID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPricelistItemsRow
	for rows.Next() {
		var i GetPricelistItemsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemName,
			&i.VariantID,
			&i.VariantName,
			&i.ItemUnitID,
			&i.UnitName,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPricelists = `-- name: GetPricelists :many
SELECT id, name, start_date, end_date, is_default
FROM inventory.pricelists
WHERE company_id = $1
AND is_deleted = false
`

type GetPricelistsRow struct {
	ID        string       `db:"id"`
	Name      string       `db:"name"`
	StartDate time.Time    `db:"start_date"`
	EndDate   sql.NullTime `db:"end_date"`
	IsDefault bool         `db:"is_default"`
}

func (q *Queries) GetPricelists(ctx context.Context, companyID string) ([]GetPricelistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPricelists, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPricelistsRow
	for rows.Next() {
		var i GetPricelistsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.IsDefault,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseItemVariantUnits = `-- name: GetPurchaseItemVariantUnits :many
SELECT DISTINCT a.primary_item_unit_id, d.name AS primary_item_unit_name,
b.value AS primary_item_unit_value,
a.secondary_item_unit_id, e.name AS secondary_item_unit_name,
c.value AS secondary_item_unit_value, f.price
FROM inventory.item_variant_maps a
JOIN inventory.item_units b ON a.primary_item_unit_id = b.id
JOIN inventory.item_units c ON a.secondary_item_unit_id = c.id
JOIN inventory.units d ON b.unit_id = d.id
JOIN inventory.units e ON c.unit_id = e.id
JOIN inventory.item_variants f ON a.primary_item_variant_id = f.id
WHERE a.primary_company_id = $1
AND a.secondary_item_variant_id = $2
AND e.name LIKE $3
`

type GetPurchaseItemVariantUnitsParams struct {
	PrimaryCompanyID       string `db:"primary_company_id"`
	SecondaryItemVariantID string `db:"secondary_item_variant_id"`
	Name                   string `db:"name"`
}

type GetPurchaseItemVariantUnitsRow struct {
	PrimaryItemUnitID      string `db:"primary_item_unit_id"`
	PrimaryItemUnitName    string `db:"primary_item_unit_name"`
	PrimaryItemUnitValue   int64  `db:"primary_item_unit_value"`
	SecondaryItemUnitID    string `db:"secondary_item_unit_id"`
	SecondaryItemUnitName  string `db:"secondary_item_unit_name"`
	SecondaryItemUnitValue int64  `db:"secondary_item_unit_value"`
	Price                  int64  `db:"price"`
}

func (q *Queries) GetPurchaseItemVariantUnits(ctx context.Context, arg GetPurchaseItemVariantUnitsParams) ([]GetPurchaseItemVariantUnitsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPurchaseItemVariantUnits, arg.PrimaryCompanyID, arg.SecondaryItemVariantID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPurchaseItemVariantUnitsRow
	for rows.Next() {
		var i GetPurchaseItemVariantUnitsRow
		if err := rows.Scan(
			&i.PrimaryItemUnitID,
			&i.PrimaryItemUnitName,
			&i.PrimaryItemUnitValue,
			&i.SecondaryItemUnitID,
			&i.SecondaryItemUnitName,
			&i.SecondaryItemUnitValue,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseItemVariants = `-- name: GetPurchaseItemVariants :many
SELECT DISTINCT a.primary_item_variant_id, b.name AS primary_item_variant_name,
a.secondary_item_variant_id, c.name AS secondary_item_variant_name
FROM inventory.item_variant_maps a
JOIN inventory.item_variants b ON a.primary_item_variant_id = b.id
JOIN inventory.item_variants c ON a.secondary_item_variant_id = c.id
WHERE a.primary_company_id = $1
AND c.item_id = $3
AND c.name LIKE $2
`

type GetPurchaseItemVariantsParams struct {
	PrimaryCompanyID string `db:"primary_company_id"`
	Name             string `db:"name"`
	SecondaryItemID  string `db:"secondary_item_id"`
}

type GetPurchaseItemVariantsRow struct {
	PrimaryItemVariantID     string `db:"primary_item_variant_id"`
	PrimaryItemVariantName   string `db:"primary_item_variant_name"`
	SecondaryItemVariantID   string `db:"secondary_item_variant_id"`
	SecondaryItemVariantName string `db:"secondary_item_variant_name"`
}

func (q *Queries) GetPurchaseItemVariants(ctx context.Context, arg GetPurchaseItemVariantsParams) ([]GetPurchaseItemVariantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPurchaseItemVariants, arg.PrimaryCompanyID, arg.Name, arg.SecondaryItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPurchaseItemVariantsRow
	for rows.Next() {
		var i GetPurchaseItemVariantsRow
		if err := rows.Scan(
			&i.PrimaryItemVariantID,
			&i.PrimaryItemVariantName,
			&i.SecondaryItemVariantID,
			&i.SecondaryItemVariantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseItems = `-- name: GetPurchaseItems :many
SELECT DISTINCT d.id AS primary_item_id,
d.code AS primary_item_code, d.name AS primary_item_name,
e.id AS secondary_item_id,
e.code AS secondary_item_code, e.name AS secondary_item_name
FROM inventory.item_variant_maps a
JOIN inventory.item_variants b ON a.primary_item_variant_id = b.id
JOIN inventory.item_variants c ON a.secondary_item_variant_id = c.id
JOIN inventory.items d ON b.item_id = d.id
JOIN inventory.items e ON c.item_id = e.id
WHERE a.primary_company_id = $1
AND a.secondary_company_id = $2
AND e.name LIKE $3
`

type GetPurchaseItemsParams struct {
	PrimaryCompanyID   string `db:"primary_company_id"`
	SecondaryCompanyID string `db:"secondary_company_id"`
	Name               string `db:"name"`
}

type GetPurchaseItemsRow struct {
	PrimaryItemID     string `db:"primary_item_id"`
	PrimaryItemCode   string `db:"primary_item_code"`
	PrimaryItemName   string `db:"primary_item_name"`
	SecondaryItemID   string `db:"secondary_item_id"`
	SecondaryItemCode string `db:"secondary_item_code"`
	SecondaryItemName string `db:"secondary_item_name"`
}

func (q *Queries) GetPurchaseItems(ctx context.Context, arg GetPurchaseItemsParams) ([]GetPurchaseItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPurchaseItems, arg.PrimaryCompanyID, arg.SecondaryCompanyID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPurchaseItemsRow
	for rows.Next() {
		var i GetPurchaseItemsRow
		if err := rows.Scan(
			&i.PrimaryItemID,
			&i.PrimaryItemCode,
			&i.PrimaryItemName,
			&i.SecondaryItemID,
			&i.SecondaryItemCode,
			&i.SecondaryItemName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockHistory = `-- name: GetStockHistory :many
SELECT a.transaction_date,
    a.form_number,
    item.id as item_id,
    item.name as item_name,
    item.image_url,
    variant.id as variant_id,
    variant.name as variant_name,
    a.beginning_stock as onhand,
    a.ending_stock as calculated
FROM inventory.update_stocks a
    JOIN inventory.item_variants variant ON variant.id = a.variant_id
    JOIN inventory.items item ON item.id = variant.item_id
WHERE a.is_deleted = false
    AND variant.item_id LIKE $1
    AND transaction_date BETWEEN $2::date AND $3::date
    AND warehouse_id = ANY($4::text [])
ORDER BY a.transaction_date DESC
`

type GetStockHistoryParams struct {
	ItemID       string    `db:"item_id"`
	StartDate    time.Time `db:"start_date"`
	EndDate      time.Time `db:"end_date"`
	WarehouseIds []string  `db:"warehouse_ids"`
}

type GetStockHistoryRow struct {
	TransactionDate time.Time `db:"transaction_date"`
	FormNumber      string    `db:"form_number"`
	ItemID          string    `db:"item_id"`
	ItemName        string    `db:"item_name"`
	ImageUrl        string    `db:"image_url"`
	VariantID       string    `db:"variant_id"`
	VariantName     string    `db:"variant_name"`
	Onhand          int64     `db:"onhand"`
	Calculated      int64     `db:"calculated"`
}

func (q *Queries) GetStockHistory(ctx context.Context, arg GetStockHistoryParams) ([]GetStockHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getStockHistory,
		arg.ItemID,
		arg.StartDate,
		arg.EndDate,
		pq.Array(arg.WarehouseIds),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStockHistoryRow
	for rows.Next() {
		var i GetStockHistoryRow
		if err := rows.Scan(
			&i.TransactionDate,
			&i.FormNumber,
			&i.ItemID,
			&i.ItemName,
			&i.ImageUrl,
			&i.VariantID,
			&i.VariantName,
			&i.Onhand,
			&i.Calculated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierCatalogs = `-- name: GetSupplierCatalogs :many
SELECT a.id,
    b.id AS variant_id,
    a.company_id,
    b.image_url,
    a.code,
    b.barcode,
    a.name,
    b.name AS variant_name,
    a.brand_id,
    COALESCE(c.name, '') AS brand_name,
    b.is_default,
    b.price,
    CASE WHEN COUNT(d.id) > 0 THEN true ELSE false END AS is_mapped
FROM inventory.items a
    JOIN inventory.item_variants b ON a.id = b.item_id
    LEFT JOIN inventory.brands c ON a.brand_id = c.id
    LEFT JOIN inventory.item_variant_maps d ON b.id = d.primary_item_variant_id
    AND d.secondary_company_id = $2
WHERE a.company_id = $1
    AND b.name LIKE $3
    AND CASE WHEN b.is_default THEN
    NOT EXISTS (
		SELECT
			1
		FROM
			inventory.item_variants a1
		WHERE
			a1.item_id = b.item_id
            AND a1.is_default is false
	)
    ELSE TRUE END
GROUP BY a.id, b.id, c.id
`

type GetSupplierCatalogsParams struct {
	CompanyID          string `db:"company_id"`
	SecondaryCompanyID string `db:"secondary_company_id"`
	Keyword            string `db:"keyword"`
}

type GetSupplierCatalogsRow struct {
	ID          string `db:"id"`
	VariantID   string `db:"variant_id"`
	CompanyID   string `db:"company_id"`
	ImageUrl    string `db:"image_url"`
	Code        string `db:"code"`
	Barcode     string `db:"barcode"`
	Name        string `db:"name"`
	VariantName string `db:"variant_name"`
	BrandID     string `db:"brand_id"`
	BrandName   string `db:"brand_name"`
	IsDefault   bool   `db:"is_default"`
	Price       int64  `db:"price"`
	IsMapped    bool   `db:"is_mapped"`
}

func (q *Queries) GetSupplierCatalogs(ctx context.Context, arg GetSupplierCatalogsParams) ([]GetSupplierCatalogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSupplierCatalogs, arg.CompanyID, arg.SecondaryCompanyID, arg.Keyword)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierCatalogsRow
	for rows.Next() {
		var i GetSupplierCatalogsRow
		if err := rows.Scan(
			&i.ID,
			&i.VariantID,
			&i.CompanyID,
			&i.ImageUrl,
			&i.Code,
			&i.Barcode,
			&i.Name,
			&i.VariantName,
			&i.BrandID,
			&i.BrandName,
			&i.IsDefault,
			&i.Price,
			&i.IsMapped,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransferHistory = `-- name: GetTransferHistory :many
SELECT b.transaction_date,
    b.form_number,
    item.id as item_id,
    item.name as item_name,
    item.image_url,
    variant.id as variant_id,
    variant.name as variant_name,
    b.source_warehouse_id,
    b.destination_warehouse_id,
    a.amount
FROM inventory.internal_stock_transfer_items a
    JOIN inventory.item_variants variant ON variant.id = a.variant_id
    JOIN inventory.items item ON item.id = variant.item_id
    JOIN inventory.internal_stock_transfers b ON b.id = a.internal_stock_transfer_id
WHERE a.is_deleted = false
    AND b.is_deleted = false
    AND variant.item_id LIKE $1
    AND transaction_date BETWEEN $5::date AND $6::date
    AND CASE WHEN $7::bool
        THEN b.is_received = $2 ELSE TRUE END
    AND (
        source_warehouse_id LIKE $3
        OR destination_warehouse_id LIKE $4
    )
    AND (
        source_warehouse_id = ANY($8::text [])
        OR destination_warehouse_id = ANY($8::text [])
    )
ORDER BY b.transaction_date DESC
`

type GetTransferHistoryParams struct {
	ItemID                 string    `db:"item_id"`
	IsReceived             bool      `db:"is_received"`
	SourceWarehouseID      string    `db:"source_warehouse_id"`
	DestinationWarehouseID string    `db:"destination_warehouse_id"`
	StartDate              time.Time `db:"start_date"`
	EndDate                time.Time `db:"end_date"`
	IsReceivedFilter       bool      `db:"is_received_filter"`
	WarehouseIds           []string  `db:"warehouse_ids"`
}

type GetTransferHistoryRow struct {
	TransactionDate        time.Time `db:"transaction_date"`
	FormNumber             string    `db:"form_number"`
	ItemID                 string    `db:"item_id"`
	ItemName               string    `db:"item_name"`
	ImageUrl               string    `db:"image_url"`
	VariantID              string    `db:"variant_id"`
	VariantName            string    `db:"variant_name"`
	SourceWarehouseID      string    `db:"source_warehouse_id"`
	DestinationWarehouseID string    `db:"destination_warehouse_id"`
	Amount                 int64     `db:"amount"`
}

func (q *Queries) GetTransferHistory(ctx context.Context, arg GetTransferHistoryParams) ([]GetTransferHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransferHistory,
		arg.ItemID,
		arg.IsReceived,
		arg.SourceWarehouseID,
		arg.DestinationWarehouseID,
		arg.StartDate,
		arg.EndDate,
		arg.IsReceivedFilter,
		pq.Array(arg.WarehouseIds),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransferHistoryRow
	for rows.Next() {
		var i GetTransferHistoryRow
		if err := rows.Scan(
			&i.TransactionDate,
			&i.FormNumber,
			&i.ItemID,
			&i.ItemName,
			&i.ImageUrl,
			&i.VariantID,
			&i.VariantName,
			&i.SourceWarehouseID,
			&i.DestinationWarehouseID,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnderMinimumOrder = `-- name: GetUnderMinimumOrder :many
SELECT 
	c.id as item_id,
	C.code AS item_code,
	C.NAME AS item_name,
	bb.id as variant_id,
	bb.NAME AS variant_name,
    e.id as unit_id,
	e.name as unit_name,
	COALESCE(A.minimum_stock, 0)  minimum_stock,
	SUM(rp.amount) amount
FROM
	inventory.stock_movements rp
	JOIN inventory.item_variants bb ON bb.ID = rp.variant_id
	JOIN inventory.items C ON bb.item_id = C.ID
    JOIN inventory.item_units d ON d.item_id = c.id
	JOIN inventory.units e ON e.id = d.unit_id AND units.value = 1
	JOIN inventory.item_reorders A ON A.variant_id = bb.ID 
WHERE rp.created_at <= NOW()
GROUP BY bb.id, c.id, e.id, rp.amount, a.minimum_stock
HAVING amount < minimum_stock
ORDER BY C.NAME, bb.NAME
`

type GetUnderMinimumOrderRow struct {
	ItemID       string `db:"item_id"`
	ItemCode     string `db:"item_code"`
	ItemName     string `db:"item_name"`
	VariantID    string `db:"variant_id"`
	VariantName  string `db:"variant_name"`
	UnitID       string `db:"unit_id"`
	UnitName     string `db:"unit_name"`
	MinimumStock int64  `db:"minimum_stock"`
	Amount       int64  `db:"amount"`
}

func (q *Queries) GetUnderMinimumOrder(ctx context.Context) ([]GetUnderMinimumOrderRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnderMinimumOrder)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnderMinimumOrderRow
	for rows.Next() {
		var i GetUnderMinimumOrderRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemCode,
			&i.ItemName,
			&i.VariantID,
			&i.VariantName,
			&i.UnitID,
			&i.UnitName,
			&i.MinimumStock,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnit = `-- name: GetUnit :one
SELECT id,
    company_id,
    name
FROM inventory.units
WHERE id = $1
`

type GetUnitRow struct {
	ID        string `db:"id"`
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

func (q *Queries) GetUnit(ctx context.Context, id string) (GetUnitRow, error) {
	row := q.db.QueryRowContext(ctx, getUnit, id)
	var i GetUnitRow
	err := row.Scan(&i.ID, &i.CompanyID, &i.Name)
	return i, err
}

const getUnitCategories = `-- name: GetUnitCategories :many
SELECT id,
    company_id,
    name
FROM inventory.unit_categories
WHERE company_id = $1
    AND name LIKE $2
`

type GetUnitCategoriesParams struct {
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

type GetUnitCategoriesRow struct {
	ID        string `db:"id"`
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

func (q *Queries) GetUnitCategories(ctx context.Context, arg GetUnitCategoriesParams) ([]GetUnitCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnitCategories, arg.CompanyID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnitCategoriesRow
	for rows.Next() {
		var i GetUnitCategoriesRow
		if err := rows.Scan(&i.ID, &i.CompanyID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnits = `-- name: GetUnits :many
SELECT id,
    company_id,
    unit_category_id,
    name
FROM inventory.units
WHERE company_id = $1
    AND unit_category_id LIKE $2
    AND name LIKE $3
`

type GetUnitsParams struct {
	CompanyID      string `db:"company_id"`
	UnitCategoryID string `db:"unit_category_id"`
	Name           string `db:"name"`
}

type GetUnitsRow struct {
	ID             string `db:"id"`
	CompanyID      string `db:"company_id"`
	UnitCategoryID string `db:"unit_category_id"`
	Name           string `db:"name"`
}

func (q *Queries) GetUnits(ctx context.Context, arg GetUnitsParams) ([]GetUnitsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnits, arg.CompanyID, arg.UnitCategoryID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnitsRow
	for rows.Next() {
		var i GetUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UnitCategoryID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpdateStock = `-- name: GetUpdateStock :one
SELECT a.id, a.form_number, a.transaction_date, a.warehouse_id, a.warehouse_rack_id,
b.item_id, c.name AS item_name, a.variant_id, b.name AS variant_name,
a.item_unit_id, e.name AS item_unit_name, a.item_unit_value,
a.beginning_stock, a.ending_stock, a.batch, a.expired_date
FROM inventory.update_stocks a
JOIN inventory.item_variants b ON a.variant_id = b.id
JOIN inventory.items c ON b.item_id = c.id
JOIN inventory.item_units d ON a.item_unit_id = d.id
JOIN inventory.units e ON d.unit_id = e.id
WHERE a.id = $1
`

type GetUpdateStockRow struct {
	ID              string         `db:"id"`
	FormNumber      string         `db:"form_number"`
	TransactionDate time.Time      `db:"transaction_date"`
	WarehouseID     string         `db:"warehouse_id"`
	WarehouseRackID string         `db:"warehouse_rack_id"`
	ItemID          string         `db:"item_id"`
	ItemName        string         `db:"item_name"`
	VariantID       string         `db:"variant_id"`
	VariantName     string         `db:"variant_name"`
	ItemUnitID      string         `db:"item_unit_id"`
	ItemUnitName    string         `db:"item_unit_name"`
	ItemUnitValue   int64          `db:"item_unit_value"`
	BeginningStock  int64          `db:"beginning_stock"`
	EndingStock     int64          `db:"ending_stock"`
	Batch           sql.NullString `db:"batch"`
	ExpiredDate     sql.NullTime   `db:"expired_date"`
}

func (q *Queries) GetUpdateStock(ctx context.Context, id string) (GetUpdateStockRow, error) {
	row := q.db.QueryRowContext(ctx, getUpdateStock, id)
	var i GetUpdateStockRow
	err := row.Scan(
		&i.ID,
		&i.FormNumber,
		&i.TransactionDate,
		&i.WarehouseID,
		&i.WarehouseRackID,
		&i.ItemID,
		&i.ItemName,
		&i.VariantID,
		&i.VariantName,
		&i.ItemUnitID,
		&i.ItemUnitName,
		&i.ItemUnitValue,
		&i.BeginningStock,
		&i.EndingStock,
		&i.Batch,
		&i.ExpiredDate,
	)
	return i, err
}

const getUpdateStocks = `-- name: GetUpdateStocks :many
SELECT a.id, a.form_number, a.transaction_date, a.warehouse_id, a.warehouse_rack_id,
b.item_id, c.name AS item_name, a.variant_id, b.name AS variant_name,
a.item_unit_id, e.name AS item_unit_name, a.item_unit_value,
a.beginning_stock, a.ending_stock, a.batch, a.expired_date
FROM inventory.update_stocks a
JOIN inventory.item_variants b ON a.variant_id = b.id
JOIN inventory.items c ON b.item_id = c.id
JOIN inventory.item_units d ON a.item_unit_id = d.id
JOIN inventory.units e ON d.unit_id = e.id
WHERE a.is_deleted = false
AND a.transaction_date BETWEEN $1::date AND $2::date
AND a.warehouse_id = ANY($3::text[])
`

type GetUpdateStocksParams struct {
	StartDate    time.Time `db:"start_date"`
	EndDate      time.Time `db:"end_date"`
	WarehouseIds []string  `db:"warehouse_ids"`
}

type GetUpdateStocksRow struct {
	ID              string         `db:"id"`
	FormNumber      string         `db:"form_number"`
	TransactionDate time.Time      `db:"transaction_date"`
	WarehouseID     string         `db:"warehouse_id"`
	WarehouseRackID string         `db:"warehouse_rack_id"`
	ItemID          string         `db:"item_id"`
	ItemName        string         `db:"item_name"`
	VariantID       string         `db:"variant_id"`
	VariantName     string         `db:"variant_name"`
	ItemUnitID      string         `db:"item_unit_id"`
	ItemUnitName    string         `db:"item_unit_name"`
	ItemUnitValue   int64          `db:"item_unit_value"`
	BeginningStock  int64          `db:"beginning_stock"`
	EndingStock     int64          `db:"ending_stock"`
	Batch           sql.NullString `db:"batch"`
	ExpiredDate     sql.NullTime   `db:"expired_date"`
}

func (q *Queries) GetUpdateStocks(ctx context.Context, arg GetUpdateStocksParams) ([]GetUpdateStocksRow, error) {
	rows, err := q.db.QueryContext(ctx, getUpdateStocks, arg.StartDate, arg.EndDate, pq.Array(arg.WarehouseIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUpdateStocksRow
	for rows.Next() {
		var i GetUpdateStocksRow
		if err := rows.Scan(
			&i.ID,
			&i.FormNumber,
			&i.TransactionDate,
			&i.WarehouseID,
			&i.WarehouseRackID,
			&i.ItemID,
			&i.ItemName,
			&i.VariantID,
			&i.VariantName,
			&i.ItemUnitID,
			&i.ItemUnitName,
			&i.ItemUnitValue,
			&i.BeginningStock,
			&i.EndingStock,
			&i.Batch,
			&i.ExpiredDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantWarehouseRackBatchExpiredDates = `-- name: GetVariantWarehouseRackBatchExpiredDates :many
SELECT DISTINCT b.expired_date
FROM inventory.stock_movements a
JOIN inventory.item_barcodes b ON a.item_barcode_id = b.id
WHERE a.variant_id = $1
AND a.warehouse_rack_id = $2
AND CASE
    WHEN $4::bool THEN b.batch is null
    ELSE b.batch = $3
END
`

type GetVariantWarehouseRackBatchExpiredDatesParams struct {
	VariantID       string         `db:"variant_id"`
	WarehouseRackID string         `db:"warehouse_rack_id"`
	Batch           sql.NullString `db:"batch"`
	IsNullBatch     bool           `db:"is_null_batch"`
}

func (q *Queries) GetVariantWarehouseRackBatchExpiredDates(ctx context.Context, arg GetVariantWarehouseRackBatchExpiredDatesParams) ([]sql.NullTime, error) {
	rows, err := q.db.QueryContext(ctx, getVariantWarehouseRackBatchExpiredDates,
		arg.VariantID,
		arg.WarehouseRackID,
		arg.Batch,
		arg.IsNullBatch,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullTime
	for rows.Next() {
		var expired_date sql.NullTime
		if err := rows.Scan(&expired_date); err != nil {
			return nil, err
		}
		items = append(items, expired_date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantWarehouseRackBatches = `-- name: GetVariantWarehouseRackBatches :many
SELECT DISTINCT b.batch
FROM inventory.stock_movements a
JOIN inventory.item_barcodes b ON a.item_barcode_id = b.id
WHERE a.variant_id = $1
AND a.warehouse_rack_id = $2
`

type GetVariantWarehouseRackBatchesParams struct {
	VariantID       string `db:"variant_id"`
	WarehouseRackID string `db:"warehouse_rack_id"`
}

func (q *Queries) GetVariantWarehouseRackBatches(ctx context.Context, arg GetVariantWarehouseRackBatchesParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getVariantWarehouseRackBatches, arg.VariantID, arg.WarehouseRackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var batch sql.NullString
		if err := rows.Scan(&batch); err != nil {
			return nil, err
		}
		items = append(items, batch)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantWarehouseRackStock = `-- name: GetVariantWarehouseRackStock :one
SELECT COALESCE(SUM(a.amount), 0)::bigint AS stock
FROM inventory.stock_movements a
JOIN inventory.item_barcodes b ON a.item_barcode_id = b.id
WHERE a.variant_id = $1
AND a.warehouse_rack_id = $2
AND CASE
    WHEN $5::bool THEN b.batch is null
    ELSE b.batch = $3
END
AND CASE
    WHEN $6::bool THEN b.expired_date is null
    ELSE b.expired_date = $4
END
`

type GetVariantWarehouseRackStockParams struct {
	VariantID         string         `db:"variant_id"`
	WarehouseRackID   string         `db:"warehouse_rack_id"`
	Batch             sql.NullString `db:"batch"`
	ExpiredDate       sql.NullTime   `db:"expired_date"`
	IsNullBatch       bool           `db:"is_null_batch"`
	IsNullExpiredDate bool           `db:"is_null_expired_date"`
}

func (q *Queries) GetVariantWarehouseRackStock(ctx context.Context, arg GetVariantWarehouseRackStockParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getVariantWarehouseRackStock,
		arg.VariantID,
		arg.WarehouseRackID,
		arg.Batch,
		arg.ExpiredDate,
		arg.IsNullBatch,
		arg.IsNullExpiredDate,
	)
	var stock int64
	err := row.Scan(&stock)
	return stock, err
}

const getVariantWarehouseRacks = `-- name: GetVariantWarehouseRacks :many
SELECT DISTINCT a.warehouse_rack_id
FROM inventory.stock_movements a
WHERE a.variant_id = $1
AND a.warehouse_id = $2
`

type GetVariantWarehouseRacksParams struct {
	VariantID   string `db:"variant_id"`
	WarehouseID string `db:"warehouse_id"`
}

func (q *Queries) GetVariantWarehouseRacks(ctx context.Context, arg GetVariantWarehouseRacksParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getVariantWarehouseRacks, arg.VariantID, arg.WarehouseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var warehouse_rack_id string
		if err := rows.Scan(&warehouse_rack_id); err != nil {
			return nil, err
		}
		items = append(items, warehouse_rack_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantWarehouseRacksByBranch = `-- name: GetVariantWarehouseRacksByBranch :many
SELECT DISTINCT a.warehouse_id, a.warehouse_rack_id
FROM inventory.stock_movements a
WHERE a.variant_id = $1
AND a.warehouse_id = ANY($2::text [])
`

type GetVariantWarehouseRacksByBranchParams struct {
	VariantID    string   `db:"variant_id"`
	WarehouseIds []string `db:"warehouse_ids"`
}

type GetVariantWarehouseRacksByBranchRow struct {
	WarehouseID     string `db:"warehouse_id"`
	WarehouseRackID string `db:"warehouse_rack_id"`
}

func (q *Queries) GetVariantWarehouseRacksByBranch(ctx context.Context, arg GetVariantWarehouseRacksByBranchParams) ([]GetVariantWarehouseRacksByBranchRow, error) {
	rows, err := q.db.QueryContext(ctx, getVariantWarehouseRacksByBranch, arg.VariantID, pq.Array(arg.WarehouseIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVariantWarehouseRacksByBranchRow
	for rows.Next() {
		var i GetVariantWarehouseRacksByBranchRow
		if err := rows.Scan(&i.WarehouseID, &i.WarehouseRackID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariantWarehouseStocks = `-- name: GetVariantWarehouseStocks :many
SELECT c.id AS item_id, c.name AS item_name,
b.id AS variant_id, b.name AS variant_name,
SUM(a.amount) AS stock
FROM inventory.stock_movements a
JOIN inventory.item_variants b ON a.variant_id = b.id
JOIN inventory.items c ON b.item_id = c.id
WHERE a.warehouse_id = $1
GROUP BY c.id, b.id
`

type GetVariantWarehouseStocksRow struct {
	ItemID      string `db:"item_id"`
	ItemName    string `db:"item_name"`
	VariantID   string `db:"variant_id"`
	VariantName string `db:"variant_name"`
	Stock       int64  `db:"stock"`
}

func (q *Queries) GetVariantWarehouseStocks(ctx context.Context, warehouseID string) ([]GetVariantWarehouseStocksRow, error) {
	rows, err := q.db.QueryContext(ctx, getVariantWarehouseStocks, warehouseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVariantWarehouseStocksRow
	for rows.Next() {
		var i GetVariantWarehouseStocksRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ItemName,
			&i.VariantID,
			&i.VariantName,
			&i.Stock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBrand = `-- name: InsertBrand :one
INSERT INTO inventory.brands(id, company_id, name)
VALUES ($1, $2, $3)
RETURNING id, company_id, name, created_at, updated_at, is_deleted
`

type InsertBrandParams struct {
	ID        string `db:"id"`
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

func (q *Queries) InsertBrand(ctx context.Context, arg InsertBrandParams) (InventoryBrand, error) {
	row := q.db.QueryRowContext(ctx, insertBrand, arg.ID, arg.CompanyID, arg.Name)
	var i InventoryBrand
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const insertGroup = `-- name: InsertGroup :one
INSERT INTO inventory.groups(id, company_id, name)
VALUES ($1, $2, $3)
RETURNING id, company_id, name, created_at, updated_at, is_deleted
`

type InsertGroupParams struct {
	ID        string `db:"id"`
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

func (q *Queries) InsertGroup(ctx context.Context, arg InsertGroupParams) (InventoryGroup, error) {
	row := q.db.QueryRowContext(ctx, insertGroup, arg.ID, arg.CompanyID, arg.Name)
	var i InventoryGroup
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const insertInternalStockTransfer = `-- name: InsertInternalStockTransfer :one
INSERT INTO inventory.internal_stock_transfers(
        id,
        source_warehouse_id,
        destination_warehouse_id,
        form_number,
        transaction_date
    )
VALUES ($1, $2, $3, $4, $5)
RETURNING id, source_warehouse_id, destination_warehouse_id, form_number, transaction_date, is_received, is_deleted, created_at, updated_at
`

type InsertInternalStockTransferParams struct {
	ID                     string    `db:"id"`
	SourceWarehouseID      string    `db:"source_warehouse_id"`
	DestinationWarehouseID string    `db:"destination_warehouse_id"`
	FormNumber             string    `db:"form_number"`
	TransactionDate        time.Time `db:"transaction_date"`
}

func (q *Queries) InsertInternalStockTransfer(ctx context.Context, arg InsertInternalStockTransferParams) (InventoryInternalStockTransfer, error) {
	row := q.db.QueryRowContext(ctx, insertInternalStockTransfer,
		arg.ID,
		arg.SourceWarehouseID,
		arg.DestinationWarehouseID,
		arg.FormNumber,
		arg.TransactionDate,
	)
	var i InventoryInternalStockTransfer
	err := row.Scan(
		&i.ID,
		&i.SourceWarehouseID,
		&i.DestinationWarehouseID,
		&i.FormNumber,
		&i.TransactionDate,
		&i.IsReceived,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertInternalStockTransferItem = `-- name: InsertInternalStockTransferItem :exec
INSERT INTO inventory.internal_stock_transfer_items(
        id,
        internal_stock_transfer_id,
        warehouse_rack_id,
        variant_id,
        item_unit_id,
        item_unit_value,
        amount,
        batch,
        expired_date,
        item_barcode_id
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type InsertInternalStockTransferItemParams struct {
	ID                      string         `db:"id"`
	InternalStockTransferID string         `db:"internal_stock_transfer_id"`
	WarehouseRackID         string         `db:"warehouse_rack_id"`
	VariantID               string         `db:"variant_id"`
	ItemUnitID              string         `db:"item_unit_id"`
	ItemUnitValue           int64          `db:"item_unit_value"`
	Amount                  int64          `db:"amount"`
	Batch                   sql.NullString `db:"batch"`
	ExpiredDate             sql.NullTime   `db:"expired_date"`
	ItemBarcodeID           string         `db:"item_barcode_id"`
}

func (q *Queries) InsertInternalStockTransferItem(ctx context.Context, arg InsertInternalStockTransferItemParams) error {
	_, err := q.db.ExecContext(ctx, insertInternalStockTransferItem,
		arg.ID,
		arg.InternalStockTransferID,
		arg.WarehouseRackID,
		arg.VariantID,
		arg.ItemUnitID,
		arg.ItemUnitValue,
		arg.Amount,
		arg.Batch,
		arg.ExpiredDate,
		arg.ItemBarcodeID,
	)
	return err
}

const insertItem = `-- name: InsertItem :one
INSERT INTO inventory.items(
        id,
        company_id,
        image_url,
        code,
        name,
        brand_id,
        group_id,
        tag,
        description
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, company_id, image_url, code, name, brand_id, group_id, tag, description, created_at, updated_at
`

type InsertItemParams struct {
	ID          string `db:"id"`
	CompanyID   string `db:"company_id"`
	ImageUrl    string `db:"image_url"`
	Code        string `db:"code"`
	Name        string `db:"name"`
	BrandID     string `db:"brand_id"`
	GroupID     string `db:"group_id"`
	Tag         string `db:"tag"`
	Description string `db:"description"`
}

func (q *Queries) InsertItem(ctx context.Context, arg InsertItemParams) (InventoryItem, error) {
	row := q.db.QueryRowContext(ctx, insertItem,
		arg.ID,
		arg.CompanyID,
		arg.ImageUrl,
		arg.Code,
		arg.Name,
		arg.BrandID,
		arg.GroupID,
		arg.Tag,
		arg.Description,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ImageUrl,
		&i.Code,
		&i.Name,
		&i.BrandID,
		&i.GroupID,
		&i.Tag,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertItemBarcode = `-- name: InsertItemBarcode :exec
INSERT INTO inventory.item_barcodes(id, variant_id, batch, expired_date)
VALUES ($1, $2, $3, $4)
`

type InsertItemBarcodeParams struct {
	ID          string         `db:"id"`
	VariantID   string         `db:"variant_id"`
	Batch       sql.NullString `db:"batch"`
	ExpiredDate sql.NullTime   `db:"expired_date"`
}

func (q *Queries) InsertItemBarcode(ctx context.Context, arg InsertItemBarcodeParams) error {
	_, err := q.db.ExecContext(ctx, insertItemBarcode,
		arg.ID,
		arg.VariantID,
		arg.Batch,
		arg.ExpiredDate,
	)
	return err
}

const insertItemVariant = `-- name: InsertItemVariant :one
INSERT INTO inventory.item_variants(
        id,
        item_id,
        image_url,
        barcode,
        name,
        price,
        is_default
    )
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, item_id, image_url, barcode, name, price, is_default, is_deleted, created_at, updated_at
`

type InsertItemVariantParams struct {
	ID        string `db:"id"`
	ItemID    string `db:"item_id"`
	ImageUrl  string `db:"image_url"`
	Barcode   string `db:"barcode"`
	Name      string `db:"name"`
	Price     int64  `db:"price"`
	IsDefault bool   `db:"is_default"`
}

func (q *Queries) InsertItemVariant(ctx context.Context, arg InsertItemVariantParams) (InventoryItemVariant, error) {
	row := q.db.QueryRowContext(ctx, insertItemVariant,
		arg.ID,
		arg.ItemID,
		arg.ImageUrl,
		arg.Barcode,
		arg.Name,
		arg.Price,
		arg.IsDefault,
	)
	var i InventoryItemVariant
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.ImageUrl,
		&i.Barcode,
		&i.Name,
		&i.Price,
		&i.IsDefault,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertStockMovement = `-- name: InsertStockMovement :exec
INSERT INTO inventory.stock_movements(
        id,
        transaction_id,
        company_id,
        branch_id,
        transaction_code,
        transaction_date,
        transaction_reference,
        detail_transaction_id,
        warehouse_id,
        warehouse_rack_id,
        variant_id,
        item_barcode_id,
        amount
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type InsertStockMovementParams struct {
	ID                   string    `db:"id"`
	TransactionID        string    `db:"transaction_id"`
	CompanyID            string    `db:"company_id"`
	BranchID             string    `db:"branch_id"`
	TransactionCode      string    `db:"transaction_code"`
	TransactionDate      time.Time `db:"transaction_date"`
	TransactionReference string    `db:"transaction_reference"`
	DetailTransactionID  string    `db:"detail_transaction_id"`
	WarehouseID          string    `db:"warehouse_id"`
	WarehouseRackID      string    `db:"warehouse_rack_id"`
	VariantID            string    `db:"variant_id"`
	ItemBarcodeID        string    `db:"item_barcode_id"`
	Amount               int64     `db:"amount"`
}

func (q *Queries) InsertStockMovement(ctx context.Context, arg InsertStockMovementParams) error {
	_, err := q.db.ExecContext(ctx, insertStockMovement,
		arg.ID,
		arg.TransactionID,
		arg.CompanyID,
		arg.BranchID,
		arg.TransactionCode,
		arg.TransactionDate,
		arg.TransactionReference,
		arg.DetailTransactionID,
		arg.WarehouseID,
		arg.WarehouseRackID,
		arg.VariantID,
		arg.ItemBarcodeID,
		arg.Amount,
	)
	return err
}

const insertUnit = `-- name: InsertUnit :one
INSERT INTO inventory.units(id, company_id, unit_category_id, name)
VALUES ($1, $2, $3, $4)
RETURNING id, unit_category_id, company_id, name, created_at, updated_at
`

type InsertUnitParams struct {
	ID             string `db:"id"`
	CompanyID      string `db:"company_id"`
	UnitCategoryID string `db:"unit_category_id"`
	Name           string `db:"name"`
}

func (q *Queries) InsertUnit(ctx context.Context, arg InsertUnitParams) (InventoryUnit, error) {
	row := q.db.QueryRowContext(ctx, insertUnit,
		arg.ID,
		arg.CompanyID,
		arg.UnitCategoryID,
		arg.Name,
	)
	var i InventoryUnit
	err := row.Scan(
		&i.ID,
		&i.UnitCategoryID,
		&i.CompanyID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertUpdateStock = `-- name: InsertUpdateStock :exec
INSERT INTO inventory.update_stocks(id,
form_number, transaction_date, warehouse_id, warehouse_rack_id,
variant_id, item_unit_id, item_unit_value, beginning_stock, ending_stock,
batch, expired_date, item_barcode_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type InsertUpdateStockParams struct {
	ID              string         `db:"id"`
	FormNumber      string         `db:"form_number"`
	TransactionDate time.Time      `db:"transaction_date"`
	WarehouseID     string         `db:"warehouse_id"`
	WarehouseRackID string         `db:"warehouse_rack_id"`
	VariantID       string         `db:"variant_id"`
	ItemUnitID      string         `db:"item_unit_id"`
	ItemUnitValue   int64          `db:"item_unit_value"`
	BeginningStock  int64          `db:"beginning_stock"`
	EndingStock     int64          `db:"ending_stock"`
	Batch           sql.NullString `db:"batch"`
	ExpiredDate     sql.NullTime   `db:"expired_date"`
	ItemBarcodeID   string         `db:"item_barcode_id"`
}

func (q *Queries) InsertUpdateStock(ctx context.Context, arg InsertUpdateStockParams) error {
	_, err := q.db.ExecContext(ctx, insertUpdateStock,
		arg.ID,
		arg.FormNumber,
		arg.TransactionDate,
		arg.WarehouseID,
		arg.WarehouseRackID,
		arg.VariantID,
		arg.ItemUnitID,
		arg.ItemUnitValue,
		arg.BeginningStock,
		arg.EndingStock,
		arg.Batch,
		arg.ExpiredDate,
		arg.ItemBarcodeID,
	)
	return err
}

const updateBrand = `-- name: UpdateBrand :one
UPDATE inventory.brands
SET name = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, name, created_at, updated_at, is_deleted
`

type UpdateBrandParams struct {
	ID   string `db:"id"`
	Name string `db:"name"`
}

func (q *Queries) UpdateBrand(ctx context.Context, arg UpdateBrandParams) (InventoryBrand, error) {
	row := q.db.QueryRowContext(ctx, updateBrand, arg.ID, arg.Name)
	var i InventoryBrand
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const updateGroup = `-- name: UpdateGroup :one
UPDATE inventory.groups
SET name = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, name, created_at, updated_at, is_deleted
`

type UpdateGroupParams struct {
	ID   string `db:"id"`
	Name string `db:"name"`
}

func (q *Queries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) (InventoryGroup, error) {
	row := q.db.QueryRowContext(ctx, updateGroup, arg.ID, arg.Name)
	var i InventoryGroup
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
	)
	return i, err
}

const updateItem = `-- name: UpdateItem :one
UPDATE inventory.items
SET image_url = $2,
    name = $3,
    brand_id = $4,
    group_id = $5,
    tag = $6,
    description = $7,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, image_url, code, name, brand_id, group_id, tag, description, created_at, updated_at
`

type UpdateItemParams struct {
	ID          string `db:"id"`
	ImageUrl    string `db:"image_url"`
	Name        string `db:"name"`
	BrandID     string `db:"brand_id"`
	GroupID     string `db:"group_id"`
	Tag         string `db:"tag"`
	Description string `db:"description"`
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) (InventoryItem, error) {
	row := q.db.QueryRowContext(ctx, updateItem,
		arg.ID,
		arg.ImageUrl,
		arg.Name,
		arg.BrandID,
		arg.GroupID,
		arg.Tag,
		arg.Description,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ImageUrl,
		&i.Code,
		&i.Name,
		&i.BrandID,
		&i.GroupID,
		&i.Tag,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateItemUnitIsDefaultToFalse = `-- name: UpdateItemUnitIsDefaultToFalse :exec
UPDATE inventory.item_units
SET is_default = false,
    updated_at = NOW()
WHERE item_id = $1
AND id <> $2
`

type UpdateItemUnitIsDefaultToFalseParams struct {
	ItemID string `db:"item_id"`
	ID     string `db:"id"`
}

func (q *Queries) UpdateItemUnitIsDefaultToFalse(ctx context.Context, arg UpdateItemUnitIsDefaultToFalseParams) error {
	_, err := q.db.ExecContext(ctx, updateItemUnitIsDefaultToFalse, arg.ItemID, arg.ID)
	return err
}

const updateItemVariantDefault = `-- name: UpdateItemVariantDefault :one
UPDATE inventory.item_variants
SET image_url = $2,
    barcode = $3,
    price = $4,
    updated_at = NOW()
WHERE item_id = $1
    AND is_default = true
RETURNING id, item_id, image_url, barcode, name, price, is_default, is_deleted, created_at, updated_at
`

type UpdateItemVariantDefaultParams struct {
	ItemID   string `db:"item_id"`
	ImageUrl string `db:"image_url"`
	Barcode  string `db:"barcode"`
	Price    int64  `db:"price"`
}

func (q *Queries) UpdateItemVariantDefault(ctx context.Context, arg UpdateItemVariantDefaultParams) (InventoryItemVariant, error) {
	row := q.db.QueryRowContext(ctx, updateItemVariantDefault,
		arg.ItemID,
		arg.ImageUrl,
		arg.Barcode,
		arg.Price,
	)
	var i InventoryItemVariant
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.ImageUrl,
		&i.Barcode,
		&i.Name,
		&i.Price,
		&i.IsDefault,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUnit = `-- name: UpdateUnit :one
UPDATE inventory.units
SET unit_category_id = $2,
    name = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, unit_category_id, company_id, name, created_at, updated_at
`

type UpdateUnitParams struct {
	ID             string `db:"id"`
	UnitCategoryID string `db:"unit_category_id"`
	Name           string `db:"name"`
}

func (q *Queries) UpdateUnit(ctx context.Context, arg UpdateUnitParams) (InventoryUnit, error) {
	row := q.db.QueryRowContext(ctx, updateUnit, arg.ID, arg.UnitCategoryID, arg.Name)
	var i InventoryUnit
	err := row.Scan(
		&i.ID,
		&i.UnitCategoryID,
		&i.CompanyID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertItemInfo = `-- name: UpsertItemInfo :exec
INSERT INTO inventory.item_infos(
        item_id,
        is_purchase,
        is_sale,
        is_raw_material,
        is_asset,
        purchase_chart_of_account_id,
        sale_chart_of_account_id,
        purchase_item_unit_id
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8) ON CONFLICT (item_id) DO
UPDATE
SET is_purchase = EXCLUDED.is_purchase,
    is_sale = EXCLUDED.is_sale,
    is_raw_material = EXCLUDED.is_raw_material,
    is_asset = EXCLUDED.is_asset,
    purchase_chart_of_account_id = EXCLUDED.purchase_chart_of_account_id,
    sale_chart_of_account_id = EXCLUDED.sale_chart_of_account_id,
    purchase_item_unit_id = EXCLUDED.purchase_item_unit_id,
    updated_at = NOW()
`

type UpsertItemInfoParams struct {
	ItemID                   string `db:"item_id"`
	IsPurchase               bool   `db:"is_purchase"`
	IsSale                   bool   `db:"is_sale"`
	IsRawMaterial            bool   `db:"is_raw_material"`
	IsAsset                  bool   `db:"is_asset"`
	PurchaseChartOfAccountID string `db:"purchase_chart_of_account_id"`
	SaleChartOfAccountID     string `db:"sale_chart_of_account_id"`
	PurchaseItemUnitID       string `db:"purchase_item_unit_id"`
}

func (q *Queries) UpsertItemInfo(ctx context.Context, arg UpsertItemInfoParams) error {
	_, err := q.db.ExecContext(ctx, upsertItemInfo,
		arg.ItemID,
		arg.IsPurchase,
		arg.IsSale,
		arg.IsRawMaterial,
		arg.IsAsset,
		arg.PurchaseChartOfAccountID,
		arg.SaleChartOfAccountID,
		arg.PurchaseItemUnitID,
	)
	return err
}

const upsertItemReorder = `-- name: UpsertItemReorder :one
INSERT INTO inventory.item_reorders(
        id,
        variant_id,
        item_unit_id,
        warehouse_id,
        minimum_stock
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (id) DO
UPDATE
SET variant_id = EXCLUDED.variant_id,
    item_unit_id = EXCLUDED.item_unit_id,
    warehouse_id = EXCLUDED.warehouse_id,
    minimum_stock = EXCLUDED.minimum_stock,
    updated_at = NOW()
RETURNING id, warehouse_id, item_unit_id, variant_id, minimum_stock, created_at, updated_at
`

type UpsertItemReorderParams struct {
	ID           string `db:"id"`
	VariantID    string `db:"variant_id"`
	ItemUnitID   string `db:"item_unit_id"`
	WarehouseID  string `db:"warehouse_id"`
	MinimumStock int64  `db:"minimum_stock"`
}

func (q *Queries) UpsertItemReorder(ctx context.Context, arg UpsertItemReorderParams) (InventoryItemReorder, error) {
	row := q.db.QueryRowContext(ctx, upsertItemReorder,
		arg.ID,
		arg.VariantID,
		arg.ItemUnitID,
		arg.WarehouseID,
		arg.MinimumStock,
	)
	var i InventoryItemReorder
	err := row.Scan(
		&i.ID,
		&i.WarehouseID,
		&i.ItemUnitID,
		&i.VariantID,
		&i.MinimumStock,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertItemUnit = `-- name: UpsertItemUnit :one
INSERT INTO inventory.item_units(id, item_id, unit_id, value, is_default)
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (id) DO
UPDATE
SET item_id = EXCLUDED.item_id,
    unit_id = EXCLUDED.unit_id,
    value = EXCLUDED.value,
    is_default = EXCLUDED.is_default,
    updated_at = NOW()
RETURNING id, item_id, unit_id, value, is_default, is_deleted, created_at, updated_at
`

type UpsertItemUnitParams struct {
	ID        string `db:"id"`
	ItemID    string `db:"item_id"`
	UnitID    string `db:"unit_id"`
	Value     int64  `db:"value"`
	IsDefault bool   `db:"is_default"`
}

func (q *Queries) UpsertItemUnit(ctx context.Context, arg UpsertItemUnitParams) (InventoryItemUnit, error) {
	row := q.db.QueryRowContext(ctx, upsertItemUnit,
		arg.ID,
		arg.ItemID,
		arg.UnitID,
		arg.Value,
		arg.IsDefault,
	)
	var i InventoryItemUnit
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.UnitID,
		&i.Value,
		&i.IsDefault,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertItemVariant = `-- name: UpsertItemVariant :exec
INSERT INTO inventory.item_variants(id, item_id, image_url, barcode, name, price)
VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (id) DO
UPDATE
SET item_id = EXCLUDED.item_id,
    image_url = EXCLUDED.image_url,
    barcode = EXCLUDED.barcode,
    name = EXCLUDED.name,
    price = EXCLUDED.price,
    updated_at = NOW()
`

type UpsertItemVariantParams struct {
	ID       string `db:"id"`
	ItemID   string `db:"item_id"`
	ImageUrl string `db:"image_url"`
	Barcode  string `db:"barcode"`
	Name     string `db:"name"`
	Price    int64  `db:"price"`
}

func (q *Queries) UpsertItemVariant(ctx context.Context, arg UpsertItemVariantParams) error {
	_, err := q.db.ExecContext(ctx, upsertItemVariant,
		arg.ID,
		arg.ItemID,
		arg.ImageUrl,
		arg.Barcode,
		arg.Name,
		arg.Price,
	)
	return err
}

const upsertItemVariantMap = `-- name: UpsertItemVariantMap :exec
INSERT INTO inventory.item_variant_maps(id,
primary_company_id, secondary_company_id,
primary_item_variant_id, secondary_item_variant_id,
primary_item_unit_id, secondary_item_unit_id)
VALUES ($1, $2, $3, $4, $5, $6, $7) ON CONFLICT (id) DO
UPDATE
SET primary_company_id = EXCLUDED.primary_company_id,
    secondary_company_id = EXCLUDED.secondary_company_id,
    primary_item_variant_id = EXCLUDED.primary_item_variant_id,
    secondary_item_variant_id = EXCLUDED.secondary_item_variant_id,
    primary_item_unit_id = EXCLUDED.primary_item_unit_id,
    secondary_item_unit_id = EXCLUDED.secondary_item_unit_id,
    updated_at = NOW()
`

type UpsertItemVariantMapParams struct {
	ID                     string `db:"id"`
	PrimaryCompanyID       string `db:"primary_company_id"`
	SecondaryCompanyID     string `db:"secondary_company_id"`
	PrimaryItemVariantID   string `db:"primary_item_variant_id"`
	SecondaryItemVariantID string `db:"secondary_item_variant_id"`
	PrimaryItemUnitID      string `db:"primary_item_unit_id"`
	SecondaryItemUnitID    string `db:"secondary_item_unit_id"`
}

func (q *Queries) UpsertItemVariantMap(ctx context.Context, arg UpsertItemVariantMapParams) error {
	_, err := q.db.ExecContext(ctx, upsertItemVariantMap,
		arg.ID,
		arg.PrimaryCompanyID,
		arg.SecondaryCompanyID,
		arg.PrimaryItemVariantID,
		arg.SecondaryItemVariantID,
		arg.PrimaryItemUnitID,
		arg.SecondaryItemUnitID,
	)
	return err
}

const upsertPricelist = `-- name: UpsertPricelist :one
INSERT INTO inventory.pricelists(id, company_id, name, start_date, end_date, is_default)
VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (id) DO
UPDATE
SET company_id = EXCLUDED.company_id,
    name = EXCLUDED.name,
    start_date = EXCLUDED.start_date,
    end_date = EXCLUDED.end_date,
    is_default = EXCLUDED.is_default,
    updated_at = NOW()
RETURNING id, company_id, name, start_date, end_date, is_default, is_deleted, created_at, updated_at
`

type UpsertPricelistParams struct {
	ID        string       `db:"id"`
	CompanyID string       `db:"company_id"`
	Name      string       `db:"name"`
	StartDate time.Time    `db:"start_date"`
	EndDate   sql.NullTime `db:"end_date"`
	IsDefault bool         `db:"is_default"`
}

func (q *Queries) UpsertPricelist(ctx context.Context, arg UpsertPricelistParams) (InventoryPricelist, error) {
	row := q.db.QueryRowContext(ctx, upsertPricelist,
		arg.ID,
		arg.CompanyID,
		arg.Name,
		arg.StartDate,
		arg.EndDate,
		arg.IsDefault,
	)
	var i InventoryPricelist
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.StartDate,
		&i.EndDate,
		&i.IsDefault,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertPricelistItem = `-- name: UpsertPricelistItem :exec
INSERT INTO inventory.pricelist_items(pricelist_id, variant_id, item_unit_id, price)
VALUES ($1, $2, $3, $4) ON CONFLICT (pricelist_id, variant_id, item_unit_id) DO
UPDATE
SET price = EXCLUDED.price,
    updated_at = NOW()
`

type UpsertPricelistItemParams struct {
	PricelistID string `db:"pricelist_id"`
	VariantID   string `db:"variant_id"`
	ItemUnitID  string `db:"item_unit_id"`
	Price       int64  `db:"price"`
}

func (q *Queries) UpsertPricelistItem(ctx context.Context, arg UpsertPricelistItemParams) error {
	_, err := q.db.ExecContext(ctx, upsertPricelistItem,
		arg.PricelistID,
		arg.VariantID,
		arg.ItemUnitID,
		arg.Price,
	)
	return err
}

const upsertUnitCategory = `-- name: UpsertUnitCategory :one
INSERT INTO inventory.unit_categories(id, company_id, name)
VALUES ($1, $2, $3) ON CONFLICT (id) DO
UPDATE
SET company_id = EXCLUDED.company_id,
    name = EXCLUDED.name,
    updated_at = NOW()
RETURNING id, company_id, name, created_at, updated_at
`

type UpsertUnitCategoryParams struct {
	ID        string `db:"id"`
	CompanyID string `db:"company_id"`
	Name      string `db:"name"`
}

func (q *Queries) UpsertUnitCategory(ctx context.Context, arg UpsertUnitCategoryParams) (InventoryUnitCategory, error) {
	row := q.db.QueryRowContext(ctx, upsertUnitCategory, arg.ID, arg.CompanyID, arg.Name)
	var i InventoryUnitCategory
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
