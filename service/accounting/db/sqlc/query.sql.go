// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const closeJournalBook = `-- name: CloseJournalBook :exec
UPDATE accounting.journal_books
SET 
    is_closed = TRUE, 
    updated_at = NOW()
WHERE id = $1 AND is_closed = FALSE
`

func (q *Queries) CloseJournalBook(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, closeJournalBook, id)
	return err
}

const deleteChartOfAccountBranches = `-- name: DeleteChartOfAccountBranches :exec
DELETE FROM accounting.chart_of_account_branches
WHERE chart_of_account_id = $1
`

func (q *Queries) DeleteChartOfAccountBranches(ctx context.Context, chartOfAccountID string) error {
	_, err := q.db.ExecContext(ctx, deleteChartOfAccountBranches, chartOfAccountID)
	return err
}

const deleteJournalBookAccount = `-- name: DeleteJournalBookAccount :exec
DELETE FROM accounting.memorial_journal_accounts
WHERE journal_book_id = $1
`

func (q *Queries) DeleteJournalBookAccount(ctx context.Context, journalBookID string) error {
	_, err := q.db.ExecContext(ctx, deleteJournalBookAccount, journalBookID)
	return err
}

const deleteMemorialJournalAccount = `-- name: DeleteMemorialJournalAccount :exec
DELETE FROM accounting.memorial_journal_accounts
WHERE memorial_journal_id = $1
`

func (q *Queries) DeleteMemorialJournalAccount(ctx context.Context, memorialJournalID string) error {
	_, err := q.db.ExecContext(ctx, deleteMemorialJournalAccount, memorialJournalID)
	return err
}

const deleteTransactionJournalByIdRef = `-- name: DeleteTransactionJournalByIdRef :exec
DELETE FROM accounting.transactions_journal
WHERE transaction_id = $1 AND transaction_reference = $2
`

type DeleteTransactionJournalByIdRefParams struct {
	TransactionID        string `db:"transaction_id"`
	TransactionReference string `db:"transaction_reference"`
}

func (q *Queries) DeleteTransactionJournalByIdRef(ctx context.Context, arg DeleteTransactionJournalByIdRefParams) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionJournalByIdRef, arg.TransactionID, arg.TransactionReference)
	return err
}

const getCashTransactions = `-- name: GetCashTransactions :many
SELECT a.id, a.company_id, a.branch_id, a.transaction_date, 
a.type, a.main_chart_of_account_id, a.contra_chart_of_account_id, 
a.amount, a.description, b.account_name AS main_chart_of_account_name, 
c.account_name AS contra_chart_of_account_name
FROM accounting.cash_transactions a
JOIN accounting.company_chart_of_accounts b ON a.main_chart_of_account_id = b.id
LEFT JOIN accounting.company_chart_of_accounts c ON a.contra_chart_of_account_id = c.id
WHERE a.company_id = $1
AND a.branch_id LIKE $2 
AND a.type LIKE $3
AND transaction_date BETWEEN $4 AND $5
`

type GetCashTransactionsParams struct {
	CompanyID string    `db:"company_id"`
	BranchID  string    `db:"branch_id"`
	Type      string    `db:"type"`
	StartDate time.Time `db:"start_date"`
	EndDate   time.Time `db:"end_date"`
}

type GetCashTransactionsRow struct {
	ID                       string         `db:"id"`
	CompanyID                string         `db:"company_id"`
	BranchID                 string         `db:"branch_id"`
	TransactionDate          time.Time      `db:"transaction_date"`
	Type                     string         `db:"type"`
	MainChartOfAccountID     string         `db:"main_chart_of_account_id"`
	ContraChartOfAccountID   string         `db:"contra_chart_of_account_id"`
	Amount                   int64          `db:"amount"`
	Description              string         `db:"description"`
	MainChartOfAccountName   string         `db:"main_chart_of_account_name"`
	ContraChartOfAccountName sql.NullString `db:"contra_chart_of_account_name"`
}

func (q *Queries) GetCashTransactions(ctx context.Context, arg GetCashTransactionsParams) ([]GetCashTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCashTransactions,
		arg.CompanyID,
		arg.BranchID,
		arg.Type,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCashTransactionsRow
	for rows.Next() {
		var i GetCashTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.BranchID,
			&i.TransactionDate,
			&i.Type,
			&i.MainChartOfAccountID,
			&i.ContraChartOfAccountID,
			&i.Amount,
			&i.Description,
			&i.MainChartOfAccountName,
			&i.ContraChartOfAccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCashTransactionsGroupByDate = `-- name: GetCashTransactionsGroupByDate :many
SELECT transaction_date, 
SUM(CASE WHEN type = 'IN' THEN amount ELSE 0 END) AS cash_in, 
SUM(CASE WHEN type = 'OUT' THEN amount ELSE 0 END) AS cash_out
FROM accounting.cash_transactions 
WHERE company_id = $1
AND branch_id LIKE $2
AND type LIKE $3
AND transaction_date BETWEEN $4 AND $5
GROUP BY transaction_date
`

type GetCashTransactionsGroupByDateParams struct {
	CompanyID string    `db:"company_id"`
	BranchID  string    `db:"branch_id"`
	Type      string    `db:"type"`
	StartDate time.Time `db:"start_date"`
	EndDate   time.Time `db:"end_date"`
}

type GetCashTransactionsGroupByDateRow struct {
	TransactionDate time.Time `db:"transaction_date"`
	CashIn          int64     `db:"cash_in"`
	CashOut         int64     `db:"cash_out"`
}

func (q *Queries) GetCashTransactionsGroupByDate(ctx context.Context, arg GetCashTransactionsGroupByDateParams) ([]GetCashTransactionsGroupByDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getCashTransactionsGroupByDate,
		arg.CompanyID,
		arg.BranchID,
		arg.Type,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCashTransactionsGroupByDateRow
	for rows.Next() {
		var i GetCashTransactionsGroupByDateRow
		if err := rows.Scan(&i.TransactionDate, &i.CashIn, &i.CashOut); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChartOfAccountBranches = `-- name: GetChartOfAccountBranches :many
SELECT chart_of_account_id, branch_id FROM accounting.chart_of_account_branches
WHERE chart_of_account_id = $1
`

type GetChartOfAccountBranchesRow struct {
	ChartOfAccountID string `db:"chart_of_account_id"`
	BranchID         string `db:"branch_id"`
}

func (q *Queries) GetChartOfAccountBranches(ctx context.Context, chartOfAccountID string) ([]GetChartOfAccountBranchesRow, error) {
	rows, err := q.db.QueryContext(ctx, getChartOfAccountBranches, chartOfAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChartOfAccountBranchesRow
	for rows.Next() {
		var i GetChartOfAccountBranchesRow
		if err := rows.Scan(&i.ChartOfAccountID, &i.BranchID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChartOfAccountGroup = `-- name: GetChartOfAccountGroup :one
SELECT id, company_id, report_type, account_type, account_group_name 
FROM accounting.chart_of_account_groups
WHERE id = $1
`

type GetChartOfAccountGroupRow struct {
	ID               string `db:"id"`
	CompanyID        string `db:"company_id"`
	ReportType       string `db:"report_type"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

func (q *Queries) GetChartOfAccountGroup(ctx context.Context, id string) (GetChartOfAccountGroupRow, error) {
	row := q.db.QueryRowContext(ctx, getChartOfAccountGroup, id)
	var i GetChartOfAccountGroupRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ReportType,
		&i.AccountType,
		&i.AccountGroupName,
	)
	return i, err
}

const getChartOfAccountGroupByAccTypeAccGroup = `-- name: GetChartOfAccountGroupByAccTypeAccGroup :one
SELECT id, company_id, report_type, account_type, account_group_name 
FROM accounting.chart_of_account_groups
WHERE company_id = $1 AND account_type = $2 AND account_group_name = $3
`

type GetChartOfAccountGroupByAccTypeAccGroupParams struct {
	CompanyID        string `db:"company_id"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

type GetChartOfAccountGroupByAccTypeAccGroupRow struct {
	ID               string `db:"id"`
	CompanyID        string `db:"company_id"`
	ReportType       string `db:"report_type"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

func (q *Queries) GetChartOfAccountGroupByAccTypeAccGroup(ctx context.Context, arg GetChartOfAccountGroupByAccTypeAccGroupParams) (GetChartOfAccountGroupByAccTypeAccGroupRow, error) {
	row := q.db.QueryRowContext(ctx, getChartOfAccountGroupByAccTypeAccGroup, arg.CompanyID, arg.AccountType, arg.AccountGroupName)
	var i GetChartOfAccountGroupByAccTypeAccGroupRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ReportType,
		&i.AccountType,
		&i.AccountGroupName,
	)
	return i, err
}

const getChartOfAccountGroups = `-- name: GetChartOfAccountGroups :many
SELECT id, company_id, report_type, account_type, account_group_name 
FROM accounting.chart_of_account_groups
WHERE company_id = $1
`

type GetChartOfAccountGroupsRow struct {
	ID               string `db:"id"`
	CompanyID        string `db:"company_id"`
	ReportType       string `db:"report_type"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

func (q *Queries) GetChartOfAccountGroups(ctx context.Context, companyID string) ([]GetChartOfAccountGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChartOfAccountGroups, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChartOfAccountGroupsRow
	for rows.Next() {
		var i GetChartOfAccountGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.ReportType,
			&i.AccountType,
			&i.AccountGroupName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyChartOfAccount = `-- name: GetCompanyChartOfAccount :one
SELECT id, company_id, currency_code, chart_of_account_group_id, account_code, account_name, bank_name, bank_account_number, bank_code, is_deleted, is_all_branches, created_at, updated_at
FROM accounting.company_chart_of_accounts
WHERE company_id = $1
`

func (q *Queries) GetCompanyChartOfAccount(ctx context.Context, companyID string) (AccountingCompanyChartOfAccount, error) {
	row := q.db.QueryRowContext(ctx, getCompanyChartOfAccount, companyID)
	var i AccountingCompanyChartOfAccount
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CurrencyCode,
		&i.ChartOfAccountGroupID,
		&i.AccountCode,
		&i.AccountName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.BankCode,
		&i.IsDeleted,
		&i.IsAllBranches,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompanyChartOfAccountBalance = `-- name: GetCompanyChartOfAccountBalance :many
SELECT chart_of_account_id, SUM(amount) AS balance
FROM accounting.transactions_journal 
WHERE company_id = $1
AND transaction_date BETWEEN $2 AND $3
GROUP BY chart_of_account_id
`

type GetCompanyChartOfAccountBalanceParams struct {
	CompanyID   string    `db:"company_id"`
	StartPeriod time.Time `db:"start_period"`
	EndPeriod   time.Time `db:"end_period"`
}

type GetCompanyChartOfAccountBalanceRow struct {
	ChartOfAccountID string `db:"chart_of_account_id"`
	Balance          int64  `db:"balance"`
}

func (q *Queries) GetCompanyChartOfAccountBalance(ctx context.Context, arg GetCompanyChartOfAccountBalanceParams) ([]GetCompanyChartOfAccountBalanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompanyChartOfAccountBalance, arg.CompanyID, arg.StartPeriod, arg.EndPeriod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyChartOfAccountBalanceRow
	for rows.Next() {
		var i GetCompanyChartOfAccountBalanceRow
		if err := rows.Scan(&i.ChartOfAccountID, &i.Balance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyChartOfAccounts = `-- name: GetCompanyChartOfAccounts :many
SELECT a.id, a.company_id, a.currency_code, a.chart_of_account_group_id,
b.report_type, b.account_type, b.account_group_name, a.account_code, a.account_name,
a.bank_name, a.bank_account_number, a.bank_code, a.is_all_branches, a.is_deleted
FROM accounting.company_chart_of_accounts a
JOIN accounting.chart_of_account_groups b ON a.chart_of_account_group_id = b.id
WHERE CASE WHEN $5::bool THEN a.id = $4
ELSE a.company_id = $1
AND a.account_name LIKE $2
AND CASE WHEN $6::bool
THEN b.account_type = ANY($7::text[]) ELSE TRUE END
AND CASE WHEN $8::bool
THEN a.is_deleted = $3 ELSE TRUE END END
`

type GetCompanyChartOfAccountsParams struct {
	CompanyID           string   `db:"company_id"`
	AccountName         string   `db:"account_name"`
	IsDeleted           bool     `db:"is_deleted"`
	ID                  string   `db:"id"`
	IsFilterID          bool     `db:"is_filter_id"`
	IsFilterJournalType bool     `db:"is_filter_journal_type"`
	AccountTypes        []string `db:"account_types"`
	IsDeletedFilter     bool     `db:"is_deleted_filter"`
}

type GetCompanyChartOfAccountsRow struct {
	ID                    string `db:"id"`
	CompanyID             string `db:"company_id"`
	CurrencyCode          string `db:"currency_code"`
	ChartOfAccountGroupID string `db:"chart_of_account_group_id"`
	ReportType            string `db:"report_type"`
	AccountType           string `db:"account_type"`
	AccountGroupName      string `db:"account_group_name"`
	AccountCode           string `db:"account_code"`
	AccountName           string `db:"account_name"`
	BankName              string `db:"bank_name"`
	BankAccountNumber     string `db:"bank_account_number"`
	BankCode              string `db:"bank_code"`
	IsAllBranches         bool   `db:"is_all_branches"`
	IsDeleted             bool   `db:"is_deleted"`
}

func (q *Queries) GetCompanyChartOfAccounts(ctx context.Context, arg GetCompanyChartOfAccountsParams) ([]GetCompanyChartOfAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompanyChartOfAccounts,
		arg.CompanyID,
		arg.AccountName,
		arg.IsDeleted,
		arg.ID,
		arg.IsFilterID,
		arg.IsFilterJournalType,
		pq.Array(arg.AccountTypes),
		arg.IsDeletedFilter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyChartOfAccountsRow
	for rows.Next() {
		var i GetCompanyChartOfAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.CurrencyCode,
			&i.ChartOfAccountGroupID,
			&i.ReportType,
			&i.AccountType,
			&i.AccountGroupName,
			&i.AccountCode,
			&i.AccountName,
			&i.BankName,
			&i.BankAccountNumber,
			&i.BankCode,
			&i.IsAllBranches,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanySettingChartOfAccount = `-- name: GetCompanySettingChartOfAccount :one
SELECT a.id, a.company_id, a.currency_code, a.chart_of_account_group_id,
b.report_type, b.account_type, b.account_group_name, a.account_code, a.account_name,
a.bank_name, a.bank_account_number, a.bank_code, a.is_all_branches, a.is_deleted
FROM accounting.company_chart_of_accounts a
JOIN accounting.chart_of_account_groups b ON a.chart_of_account_group_id = b.id
WHERE a.company_id = $1
AND b.account_group_name = $2
ORDER BY a.created_at LIMIT 1
`

type GetCompanySettingChartOfAccountParams struct {
	CompanyID        string `db:"company_id"`
	AccountGroupName string `db:"account_group_name"`
}

type GetCompanySettingChartOfAccountRow struct {
	ID                    string `db:"id"`
	CompanyID             string `db:"company_id"`
	CurrencyCode          string `db:"currency_code"`
	ChartOfAccountGroupID string `db:"chart_of_account_group_id"`
	ReportType            string `db:"report_type"`
	AccountType           string `db:"account_type"`
	AccountGroupName      string `db:"account_group_name"`
	AccountCode           string `db:"account_code"`
	AccountName           string `db:"account_name"`
	BankName              string `db:"bank_name"`
	BankAccountNumber     string `db:"bank_account_number"`
	BankCode              string `db:"bank_code"`
	IsAllBranches         bool   `db:"is_all_branches"`
	IsDeleted             bool   `db:"is_deleted"`
}

func (q *Queries) GetCompanySettingChartOfAccount(ctx context.Context, arg GetCompanySettingChartOfAccountParams) (GetCompanySettingChartOfAccountRow, error) {
	row := q.db.QueryRowContext(ctx, getCompanySettingChartOfAccount, arg.CompanyID, arg.AccountGroupName)
	var i GetCompanySettingChartOfAccountRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CurrencyCode,
		&i.ChartOfAccountGroupID,
		&i.ReportType,
		&i.AccountType,
		&i.AccountGroupName,
		&i.AccountCode,
		&i.AccountName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.BankCode,
		&i.IsAllBranches,
		&i.IsDeleted,
	)
	return i, err
}

const getJournalBook = `-- name: GetJournalBook :one
SELECT id, company_id, name, start_period, end_period, is_closed, created_at, updated_at
FROM accounting.journal_books
WHERE id = $1
`

func (q *Queries) GetJournalBook(ctx context.Context, id string) (AccountingJournalBook, error) {
	row := q.db.QueryRowContext(ctx, getJournalBook, id)
	var i AccountingJournalBook
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.StartPeriod,
		&i.EndPeriod,
		&i.IsClosed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJournalBookAccounts = `-- name: GetJournalBookAccounts :many
SELECT a.journal_book_id, a.chart_of_account_id, 
c.account_type, c.account_group_name, b.account_name, 
a.debit_amount, a.credit_amount, a.description
FROM accounting.memorial_journal_accounts a
JOIN accounting.company_chart_of_accounts b ON a.chart_of_account_id = b.id
JOIN accounting.chart_of_account_groups c ON b.chart_of_account_group_id = c.id
WHERE journal_book_id = $1
`

type GetJournalBookAccountsRow struct {
	JournalBookID    string `db:"journal_book_id"`
	ChartOfAccountID string `db:"chart_of_account_id"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
	AccountName      string `db:"account_name"`
	DebitAmount      int64  `db:"debit_amount"`
	CreditAmount     int64  `db:"credit_amount"`
	Description      string `db:"description"`
}

func (q *Queries) GetJournalBookAccounts(ctx context.Context, journalBookID string) ([]GetJournalBookAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getJournalBookAccounts, journalBookID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJournalBookAccountsRow
	for rows.Next() {
		var i GetJournalBookAccountsRow
		if err := rows.Scan(
			&i.JournalBookID,
			&i.ChartOfAccountID,
			&i.AccountType,
			&i.AccountGroupName,
			&i.AccountName,
			&i.DebitAmount,
			&i.CreditAmount,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJournalBooks = `-- name: GetJournalBooks :many
SELECT id, company_id, name, start_period, end_period, is_closed, created_at, updated_at
FROM accounting.journal_books
WHERE company_id = $1
`

func (q *Queries) GetJournalBooks(ctx context.Context, companyID string) ([]AccountingJournalBook, error) {
	rows, err := q.db.QueryContext(ctx, getJournalBooks, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountingJournalBook
	for rows.Next() {
		var i AccountingJournalBook
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.StartPeriod,
			&i.EndPeriod,
			&i.IsClosed,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemorialJournalAccounts = `-- name: GetMemorialJournalAccounts :many
SELECT a.memorial_journal_id, a.chart_of_account_id, 
c.account_type, c.account_group_name, b.account_name, 
a.debit_amount, a.credit_amount, a.description
FROM accounting.memorial_journal_accounts a
JOIN accounting.company_chart_of_accounts b ON a.chart_of_account_id = b.id
JOIN accounting.chart_of_account_groups c ON b.chart_of_account_group_id = c.id
WHERE memorial_journal_id = $1
`

type GetMemorialJournalAccountsRow struct {
	MemorialJournalID string `db:"memorial_journal_id"`
	ChartOfAccountID  string `db:"chart_of_account_id"`
	AccountType       string `db:"account_type"`
	AccountGroupName  string `db:"account_group_name"`
	AccountName       string `db:"account_name"`
	DebitAmount       int64  `db:"debit_amount"`
	CreditAmount      int64  `db:"credit_amount"`
	Description       string `db:"description"`
}

func (q *Queries) GetMemorialJournalAccounts(ctx context.Context, memorialJournalID string) ([]GetMemorialJournalAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMemorialJournalAccounts, memorialJournalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMemorialJournalAccountsRow
	for rows.Next() {
		var i GetMemorialJournalAccountsRow
		if err := rows.Scan(
			&i.MemorialJournalID,
			&i.ChartOfAccountID,
			&i.AccountType,
			&i.AccountGroupName,
			&i.AccountName,
			&i.DebitAmount,
			&i.CreditAmount,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMemorialJournals = `-- name: GetMemorialJournals :many
SELECT id, company_id, transaction_date, description, created_at, updated_at
FROM accounting.memorial_journals
WHERE company_id = $1
`

func (q *Queries) GetMemorialJournals(ctx context.Context, companyID string) ([]AccountingMemorialJournal, error) {
	rows, err := q.db.QueryContext(ctx, getMemorialJournals, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountingMemorialJournal
	for rows.Next() {
		var i AccountingMemorialJournal
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.TransactionDate,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCashTransaction = `-- name: InsertCashTransaction :one
INSERT INTO accounting.cash_transactions(id, company_id, branch_id, transaction_date, 
type, main_chart_of_account_id, contra_chart_of_account_id, 
amount, description)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, company_id, branch_id, transaction_date, type, main_chart_of_account_id, contra_chart_of_account_id, amount, description, created_at, updated_at
`

type InsertCashTransactionParams struct {
	ID                     string    `db:"id"`
	CompanyID              string    `db:"company_id"`
	BranchID               string    `db:"branch_id"`
	TransactionDate        time.Time `db:"transaction_date"`
	Type                   string    `db:"type"`
	MainChartOfAccountID   string    `db:"main_chart_of_account_id"`
	ContraChartOfAccountID string    `db:"contra_chart_of_account_id"`
	Amount                 int64     `db:"amount"`
	Description            string    `db:"description"`
}

func (q *Queries) InsertCashTransaction(ctx context.Context, arg InsertCashTransactionParams) (AccountingCashTransaction, error) {
	row := q.db.QueryRowContext(ctx, insertCashTransaction,
		arg.ID,
		arg.CompanyID,
		arg.BranchID,
		arg.TransactionDate,
		arg.Type,
		arg.MainChartOfAccountID,
		arg.ContraChartOfAccountID,
		arg.Amount,
		arg.Description,
	)
	var i AccountingCashTransaction
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.BranchID,
		&i.TransactionDate,
		&i.Type,
		&i.MainChartOfAccountID,
		&i.ContraChartOfAccountID,
		&i.Amount,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertChartOfAccountBranches = `-- name: InsertChartOfAccountBranches :exec
INSERT INTO accounting.chart_of_account_branches(chart_of_account_id, branch_id)
VALUES ($1, $2)
`

type InsertChartOfAccountBranchesParams struct {
	ChartOfAccountID string `db:"chart_of_account_id"`
	BranchID         string `db:"branch_id"`
}

func (q *Queries) InsertChartOfAccountBranches(ctx context.Context, arg InsertChartOfAccountBranchesParams) error {
	_, err := q.db.ExecContext(ctx, insertChartOfAccountBranches, arg.ChartOfAccountID, arg.BranchID)
	return err
}

const insertChartOfAccountGroup = `-- name: InsertChartOfAccountGroup :one
INSERT INTO accounting.chart_of_account_groups(id, company_id, 
report_type, account_type, account_group_name)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, company_id, report_type, account_type, account_group_name, created_at, updated_at
`

type InsertChartOfAccountGroupParams struct {
	ID               string `db:"id"`
	CompanyID        string `db:"company_id"`
	ReportType       string `db:"report_type"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

func (q *Queries) InsertChartOfAccountGroup(ctx context.Context, arg InsertChartOfAccountGroupParams) (AccountingChartOfAccountGroup, error) {
	row := q.db.QueryRowContext(ctx, insertChartOfAccountGroup,
		arg.ID,
		arg.CompanyID,
		arg.ReportType,
		arg.AccountType,
		arg.AccountGroupName,
	)
	var i AccountingChartOfAccountGroup
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ReportType,
		&i.AccountType,
		&i.AccountGroupName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertCompanyChartOfAccount = `-- name: InsertCompanyChartOfAccount :one
INSERT INTO accounting.company_chart_of_accounts(id, company_id, currency_code, 
chart_of_account_group_id, account_code, account_name, 
bank_name, bank_account_number, bank_code, is_all_branches)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, company_id, currency_code, chart_of_account_group_id, account_code, account_name, bank_name, bank_account_number, bank_code, is_deleted, is_all_branches, created_at, updated_at
`

type InsertCompanyChartOfAccountParams struct {
	ID                    string `db:"id"`
	CompanyID             string `db:"company_id"`
	CurrencyCode          string `db:"currency_code"`
	ChartOfAccountGroupID string `db:"chart_of_account_group_id"`
	AccountCode           string `db:"account_code"`
	AccountName           string `db:"account_name"`
	BankName              string `db:"bank_name"`
	BankAccountNumber     string `db:"bank_account_number"`
	BankCode              string `db:"bank_code"`
	IsAllBranches         bool   `db:"is_all_branches"`
}

func (q *Queries) InsertCompanyChartOfAccount(ctx context.Context, arg InsertCompanyChartOfAccountParams) (AccountingCompanyChartOfAccount, error) {
	row := q.db.QueryRowContext(ctx, insertCompanyChartOfAccount,
		arg.ID,
		arg.CompanyID,
		arg.CurrencyCode,
		arg.ChartOfAccountGroupID,
		arg.AccountCode,
		arg.AccountName,
		arg.BankName,
		arg.BankAccountNumber,
		arg.BankCode,
		arg.IsAllBranches,
	)
	var i AccountingCompanyChartOfAccount
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CurrencyCode,
		&i.ChartOfAccountGroupID,
		&i.AccountCode,
		&i.AccountName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.BankCode,
		&i.IsDeleted,
		&i.IsAllBranches,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertJournalBook = `-- name: InsertJournalBook :one
INSERT INTO accounting.journal_books(id, company_id, 
name, start_period, end_period)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, company_id, name, start_period, end_period, is_closed, created_at, updated_at
`

type InsertJournalBookParams struct {
	ID          string    `db:"id"`
	CompanyID   string    `db:"company_id"`
	Name        string    `db:"name"`
	StartPeriod time.Time `db:"start_period"`
	EndPeriod   time.Time `db:"end_period"`
}

func (q *Queries) InsertJournalBook(ctx context.Context, arg InsertJournalBookParams) (AccountingJournalBook, error) {
	row := q.db.QueryRowContext(ctx, insertJournalBook,
		arg.ID,
		arg.CompanyID,
		arg.Name,
		arg.StartPeriod,
		arg.EndPeriod,
	)
	var i AccountingJournalBook
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.StartPeriod,
		&i.EndPeriod,
		&i.IsClosed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertJournalBookAccount = `-- name: InsertJournalBookAccount :exec
INSERT INTO accounting.memorial_journal_accounts(journal_book_id, chart_of_account_id, 
debit_amount, credit_amount, description)
VALUES ($1, $2, $3, $4, $5)
`

type InsertJournalBookAccountParams struct {
	JournalBookID    string `db:"journal_book_id"`
	ChartOfAccountID string `db:"chart_of_account_id"`
	DebitAmount      int64  `db:"debit_amount"`
	CreditAmount     int64  `db:"credit_amount"`
	Description      string `db:"description"`
}

func (q *Queries) InsertJournalBookAccount(ctx context.Context, arg InsertJournalBookAccountParams) error {
	_, err := q.db.ExecContext(ctx, insertJournalBookAccount,
		arg.JournalBookID,
		arg.ChartOfAccountID,
		arg.DebitAmount,
		arg.CreditAmount,
		arg.Description,
	)
	return err
}

const insertMemorialJournal = `-- name: InsertMemorialJournal :one
INSERT INTO accounting.memorial_journals(id, company_id, 
transaction_date, description)
VALUES ($1, $2, $3, $4)
RETURNING id, company_id, transaction_date, description, created_at, updated_at
`

type InsertMemorialJournalParams struct {
	ID              string    `db:"id"`
	CompanyID       string    `db:"company_id"`
	TransactionDate time.Time `db:"transaction_date"`
	Description     string    `db:"description"`
}

func (q *Queries) InsertMemorialJournal(ctx context.Context, arg InsertMemorialJournalParams) (AccountingMemorialJournal, error) {
	row := q.db.QueryRowContext(ctx, insertMemorialJournal,
		arg.ID,
		arg.CompanyID,
		arg.TransactionDate,
		arg.Description,
	)
	var i AccountingMemorialJournal
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.TransactionDate,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertMemorialJournalAccount = `-- name: InsertMemorialJournalAccount :exec
INSERT INTO accounting.memorial_journal_accounts(memorial_journal_id, chart_of_account_id, 
debit_amount, credit_amount, description)
VALUES ($1, $2, $3, $4, $5)
`

type InsertMemorialJournalAccountParams struct {
	MemorialJournalID string `db:"memorial_journal_id"`
	ChartOfAccountID  string `db:"chart_of_account_id"`
	DebitAmount       int64  `db:"debit_amount"`
	CreditAmount      int64  `db:"credit_amount"`
	Description       string `db:"description"`
}

func (q *Queries) InsertMemorialJournalAccount(ctx context.Context, arg InsertMemorialJournalAccountParams) error {
	_, err := q.db.ExecContext(ctx, insertMemorialJournalAccount,
		arg.MemorialJournalID,
		arg.ChartOfAccountID,
		arg.DebitAmount,
		arg.CreditAmount,
		arg.Description,
	)
	return err
}

const insertTransactionJournal = `-- name: InsertTransactionJournal :one
INSERT INTO accounting.transactions_journal(company_id, branch_id, transaction_id, 
transaction_date, transaction_reference , chart_of_account_id, 
amount, description)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING company_id, branch_id, transaction_id, transaction_date, transaction_reference, chart_of_account_id, amount, description, created_at
`

type InsertTransactionJournalParams struct {
	CompanyID            string    `db:"company_id"`
	BranchID             string    `db:"branch_id"`
	TransactionID        string    `db:"transaction_id"`
	TransactionDate      time.Time `db:"transaction_date"`
	TransactionReference string    `db:"transaction_reference"`
	ChartOfAccountID     string    `db:"chart_of_account_id"`
	Amount               int64     `db:"amount"`
	Description          string    `db:"description"`
}

func (q *Queries) InsertTransactionJournal(ctx context.Context, arg InsertTransactionJournalParams) (AccountingTransactionsJournal, error) {
	row := q.db.QueryRowContext(ctx, insertTransactionJournal,
		arg.CompanyID,
		arg.BranchID,
		arg.TransactionID,
		arg.TransactionDate,
		arg.TransactionReference,
		arg.ChartOfAccountID,
		arg.Amount,
		arg.Description,
	)
	var i AccountingTransactionsJournal
	err := row.Scan(
		&i.CompanyID,
		&i.BranchID,
		&i.TransactionID,
		&i.TransactionDate,
		&i.TransactionReference,
		&i.ChartOfAccountID,
		&i.Amount,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const updateChartOfAccountGroup = `-- name: UpdateChartOfAccountGroup :one
UPDATE accounting.chart_of_account_groups
SET 
    report_type = $2,
    account_type = $3,
    account_group_name = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, report_type, account_type, account_group_name, created_at, updated_at
`

type UpdateChartOfAccountGroupParams struct {
	ID               string `db:"id"`
	ReportType       string `db:"report_type"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

func (q *Queries) UpdateChartOfAccountGroup(ctx context.Context, arg UpdateChartOfAccountGroupParams) (AccountingChartOfAccountGroup, error) {
	row := q.db.QueryRowContext(ctx, updateChartOfAccountGroup,
		arg.ID,
		arg.ReportType,
		arg.AccountType,
		arg.AccountGroupName,
	)
	var i AccountingChartOfAccountGroup
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ReportType,
		&i.AccountType,
		&i.AccountGroupName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCompanyChartOfAccount = `-- name: UpdateCompanyChartOfAccount :one
UPDATE accounting.company_chart_of_accounts
SET 
    currency_code = $2,
    chart_of_account_group_id = $3,
    account_code = $4,
    account_name = $5,
    bank_name = $6,
    bank_account_number = $7,
    bank_code = $8,
    is_all_branches = $9,
    is_deleted = $10,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, currency_code, chart_of_account_group_id, account_code, account_name, bank_name, bank_account_number, bank_code, is_deleted, is_all_branches, created_at, updated_at
`

type UpdateCompanyChartOfAccountParams struct {
	ID                    string `db:"id"`
	CurrencyCode          string `db:"currency_code"`
	ChartOfAccountGroupID string `db:"chart_of_account_group_id"`
	AccountCode           string `db:"account_code"`
	AccountName           string `db:"account_name"`
	BankName              string `db:"bank_name"`
	BankAccountNumber     string `db:"bank_account_number"`
	BankCode              string `db:"bank_code"`
	IsAllBranches         bool   `db:"is_all_branches"`
	IsDeleted             bool   `db:"is_deleted"`
}

func (q *Queries) UpdateCompanyChartOfAccount(ctx context.Context, arg UpdateCompanyChartOfAccountParams) (AccountingCompanyChartOfAccount, error) {
	row := q.db.QueryRowContext(ctx, updateCompanyChartOfAccount,
		arg.ID,
		arg.CurrencyCode,
		arg.ChartOfAccountGroupID,
		arg.AccountCode,
		arg.AccountName,
		arg.BankName,
		arg.BankAccountNumber,
		arg.BankCode,
		arg.IsAllBranches,
		arg.IsDeleted,
	)
	var i AccountingCompanyChartOfAccount
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CurrencyCode,
		&i.ChartOfAccountGroupID,
		&i.AccountCode,
		&i.AccountName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.BankCode,
		&i.IsDeleted,
		&i.IsAllBranches,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateJournalBook = `-- name: UpdateJournalBook :one
UPDATE accounting.journal_books
SET
    name = $2,
    start_period = $3,
    end_period = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, name, start_period, end_period, is_closed, created_at, updated_at
`

type UpdateJournalBookParams struct {
	ID          string    `db:"id"`
	Name        string    `db:"name"`
	StartPeriod time.Time `db:"start_period"`
	EndPeriod   time.Time `db:"end_period"`
}

func (q *Queries) UpdateJournalBook(ctx context.Context, arg UpdateJournalBookParams) (AccountingJournalBook, error) {
	row := q.db.QueryRowContext(ctx, updateJournalBook,
		arg.ID,
		arg.Name,
		arg.StartPeriod,
		arg.EndPeriod,
	)
	var i AccountingJournalBook
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.StartPeriod,
		&i.EndPeriod,
		&i.IsClosed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemorialJournal = `-- name: UpdateMemorialJournal :one
UPDATE accounting.memorial_journals
SET
    transaction_date = $2,
    description = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, transaction_date, description, created_at, updated_at
`

type UpdateMemorialJournalParams struct {
	ID              string    `db:"id"`
	TransactionDate time.Time `db:"transaction_date"`
	Description     string    `db:"description"`
}

func (q *Queries) UpdateMemorialJournal(ctx context.Context, arg UpdateMemorialJournalParams) (AccountingMemorialJournal, error) {
	row := q.db.QueryRowContext(ctx, updateMemorialJournal, arg.ID, arg.TransactionDate, arg.Description)
	var i AccountingMemorialJournal
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.TransactionDate,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
