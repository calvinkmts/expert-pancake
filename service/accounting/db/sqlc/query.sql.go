// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package db

import (
	"context"
)

const getCompanyChartOfAccounts = `-- name: GetCompanyChartOfAccounts :many
SELECT id, company_id, branch_id, account_code, account_name, account_group, bank_name, 
bank_account_number, bank_code, opening_balance, is_deleted
FROM accounting.company_chart_of_accounts
WHERE company_id = $1 AND account_name LIKE $2
`

type GetCompanyChartOfAccountsParams struct {
	CompanyID   string `db:"company_id"`
	AccountName string `db:"account_name"`
}

type GetCompanyChartOfAccountsRow struct {
	ID                string  `db:"id"`
	CompanyID         string  `db:"company_id"`
	BranchID          string  `db:"branch_id"`
	AccountCode       string  `db:"account_code"`
	AccountName       string  `db:"account_name"`
	AccountGroup      string  `db:"account_group"`
	BankName          string  `db:"bank_name"`
	BankAccountNumber string  `db:"bank_account_number"`
	BankCode          string  `db:"bank_code"`
	OpeningBalance    float64 `db:"opening_balance"`
	IsDeleted         int32   `db:"is_deleted"`
}

func (q *Queries) GetCompanyChartOfAccounts(ctx context.Context, arg GetCompanyChartOfAccountsParams) ([]GetCompanyChartOfAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompanyChartOfAccounts, arg.CompanyID, arg.AccountName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyChartOfAccountsRow
	for rows.Next() {
		var i GetCompanyChartOfAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.BranchID,
			&i.AccountCode,
			&i.AccountName,
			&i.AccountGroup,
			&i.BankName,
			&i.BankAccountNumber,
			&i.BankCode,
			&i.OpeningBalance,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCompanyChartOfAccount = `-- name: UpsertCompanyChartOfAccount :one
INSERT INTO accounting.company_chart_of_accounts(id, company_id, branch_id, 
account_code, account_name, account_group, 
bank_name, bank_account_number, bank_code, opening_balance, is_deleted)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT (id)
DO UPDATE SET
    account_code = EXCLUDED.account_code,
    account_name = EXCLUDED.account_name,
    account_group = EXCLUDED.account_group,
    bank_name = EXCLUDED.bank_name,
    bank_account_number = EXCLUDED.bank_account_number,
    bank_code = EXCLUDED.bank_code,
    opening_balance = EXCLUDED.opening_balance,
    is_deleted = EXCLUDED.is_deleted,
    updated_at = NOW()
RETURNING id, company_id, branch_id, account_code, account_name, account_group, bank_name, bank_account_number, bank_code, opening_balance, is_deleted, created_at, updated_at
`

type UpsertCompanyChartOfAccountParams struct {
	ID                string  `db:"id"`
	CompanyID         string  `db:"company_id"`
	BranchID          string  `db:"branch_id"`
	AccountCode       string  `db:"account_code"`
	AccountName       string  `db:"account_name"`
	AccountGroup      string  `db:"account_group"`
	BankName          string  `db:"bank_name"`
	BankAccountNumber string  `db:"bank_account_number"`
	BankCode          string  `db:"bank_code"`
	OpeningBalance    float64 `db:"opening_balance"`
	IsDeleted         int32   `db:"is_deleted"`
}

func (q *Queries) UpsertCompanyChartOfAccount(ctx context.Context, arg UpsertCompanyChartOfAccountParams) (AccountingCompanyChartOfAccount, error) {
	row := q.db.QueryRowContext(ctx, upsertCompanyChartOfAccount,
		arg.ID,
		arg.CompanyID,
		arg.BranchID,
		arg.AccountCode,
		arg.AccountName,
		arg.AccountGroup,
		arg.BankName,
		arg.BankAccountNumber,
		arg.BankCode,
		arg.OpeningBalance,
		arg.IsDeleted,
	)
	var i AccountingCompanyChartOfAccount
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.BranchID,
		&i.AccountCode,
		&i.AccountName,
		&i.AccountGroup,
		&i.BankName,
		&i.BankAccountNumber,
		&i.BankCode,
		&i.OpeningBalance,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertCompanyFiscalYear = `-- name: UpsertCompanyFiscalYear :one
INSERT INTO accounting.company_fiscal_years(company_id, start_month, start_year, end_month, end_year)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (company_id)
DO UPDATE SET
    start_month = EXCLUDED.start_month,
    start_year = EXCLUDED.start_year,
    end_month = EXCLUDED.end_month,
    end_year = EXCLUDED.end_year,
    updated_at = NOW()
RETURNING company_id, start_month, start_year, end_month, end_year, created_at, updated_at
`

type UpsertCompanyFiscalYearParams struct {
	CompanyID  string `db:"company_id"`
	StartMonth int32  `db:"start_month"`
	StartYear  int32  `db:"start_year"`
	EndMonth   int32  `db:"end_month"`
	EndYear    int32  `db:"end_year"`
}

func (q *Queries) UpsertCompanyFiscalYear(ctx context.Context, arg UpsertCompanyFiscalYearParams) (AccountingCompanyFiscalYear, error) {
	row := q.db.QueryRowContext(ctx, upsertCompanyFiscalYear,
		arg.CompanyID,
		arg.StartMonth,
		arg.StartYear,
		arg.EndMonth,
		arg.EndYear,
	)
	var i AccountingCompanyFiscalYear
	err := row.Scan(
		&i.CompanyID,
		&i.StartMonth,
		&i.StartYear,
		&i.EndMonth,
		&i.EndYear,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
