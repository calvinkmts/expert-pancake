// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const deleteChartOfAccountBranches = `-- name: DeleteChartOfAccountBranches :exec
DELETE FROM accounting.chart_of_account_branches
WHERE chart_of_account_id = $1
`

func (q *Queries) DeleteChartOfAccountBranches(ctx context.Context, chartOfAccountID string) error {
	_, err := q.db.ExecContext(ctx, deleteChartOfAccountBranches, chartOfAccountID)
	return err
}

const getCashTransactions = `-- name: GetCashTransactions :many
SELECT a.id, a.company_id, a.branch_id, a.transaction_date, 
a.type, a.main_chart_of_account_id, a.contra_chart_of_account_id, 
a.amount, a.description, b.account_name AS main_chart_of_account_name, 
c.account_name AS contra_chart_of_account_name
FROM accounting.cash_transactions a
JOIN accounting.company_chart_of_accounts b ON a.main_chart_of_account_id = b.id
LEFT JOIN accounting.company_chart_of_accounts c ON a.contra_chart_of_account_id = c.id
WHERE a.company_id = $1
AND a.branch_id = $2 
AND a.type LIKE $3
`

type GetCashTransactionsParams struct {
	CompanyID string `db:"company_id"`
	BranchID  string `db:"branch_id"`
	Type      string `db:"type"`
}

type GetCashTransactionsRow struct {
	ID                       string         `db:"id"`
	CompanyID                string         `db:"company_id"`
	BranchID                 string         `db:"branch_id"`
	TransactionDate          time.Time      `db:"transaction_date"`
	Type                     string         `db:"type"`
	MainChartOfAccountID     string         `db:"main_chart_of_account_id"`
	ContraChartOfAccountID   string         `db:"contra_chart_of_account_id"`
	Amount                   int64          `db:"amount"`
	Description              string         `db:"description"`
	MainChartOfAccountName   string         `db:"main_chart_of_account_name"`
	ContraChartOfAccountName sql.NullString `db:"contra_chart_of_account_name"`
}

func (q *Queries) GetCashTransactions(ctx context.Context, arg GetCashTransactionsParams) ([]GetCashTransactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCashTransactions, arg.CompanyID, arg.BranchID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCashTransactionsRow
	for rows.Next() {
		var i GetCashTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.BranchID,
			&i.TransactionDate,
			&i.Type,
			&i.MainChartOfAccountID,
			&i.ContraChartOfAccountID,
			&i.Amount,
			&i.Description,
			&i.MainChartOfAccountName,
			&i.ContraChartOfAccountName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCashTransactionsGroupByDate = `-- name: GetCashTransactionsGroupByDate :many
SELECT transaction_date, 
SUM(CASE WHEN type = 'IN' THEN amount ELSE 0 END) AS cash_in, 
SUM(CASE WHEN type = 'OUT' THEN amount ELSE 0 END) AS cash_out
FROM accounting.cash_transactions 
WHERE company_id = $1
AND branch_id = $2
GROUP BY transaction_date
`

type GetCashTransactionsGroupByDateParams struct {
	CompanyID string `db:"company_id"`
	BranchID  string `db:"branch_id"`
}

type GetCashTransactionsGroupByDateRow struct {
	TransactionDate time.Time `db:"transaction_date"`
	CashIn          int64     `db:"cash_in"`
	CashOut         int64     `db:"cash_out"`
}

func (q *Queries) GetCashTransactionsGroupByDate(ctx context.Context, arg GetCashTransactionsGroupByDateParams) ([]GetCashTransactionsGroupByDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getCashTransactionsGroupByDate, arg.CompanyID, arg.BranchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCashTransactionsGroupByDateRow
	for rows.Next() {
		var i GetCashTransactionsGroupByDateRow
		if err := rows.Scan(&i.TransactionDate, &i.CashIn, &i.CashOut); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChartOfAccountBranches = `-- name: GetChartOfAccountBranches :many
SELECT chart_of_account_id, branch_id FROM accounting.chart_of_account_branches
WHERE chart_of_account_id = $1
`

type GetChartOfAccountBranchesRow struct {
	ChartOfAccountID string `db:"chart_of_account_id"`
	BranchID         string `db:"branch_id"`
}

func (q *Queries) GetChartOfAccountBranches(ctx context.Context, chartOfAccountID string) ([]GetChartOfAccountBranchesRow, error) {
	rows, err := q.db.QueryContext(ctx, getChartOfAccountBranches, chartOfAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChartOfAccountBranchesRow
	for rows.Next() {
		var i GetChartOfAccountBranchesRow
		if err := rows.Scan(&i.ChartOfAccountID, &i.BranchID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChartOfAccountGroup = `-- name: GetChartOfAccountGroup :one
SELECT id, company_id, report_type, account_type, account_group_name 
FROM accounting.chart_of_account_groups
WHERE id = $1
`

type GetChartOfAccountGroupRow struct {
	ID               string `db:"id"`
	CompanyID        string `db:"company_id"`
	ReportType       string `db:"report_type"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

func (q *Queries) GetChartOfAccountGroup(ctx context.Context, id string) (GetChartOfAccountGroupRow, error) {
	row := q.db.QueryRowContext(ctx, getChartOfAccountGroup, id)
	var i GetChartOfAccountGroupRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ReportType,
		&i.AccountType,
		&i.AccountGroupName,
	)
	return i, err
}

const getChartOfAccountGroupByAccTypeAccGroup = `-- name: GetChartOfAccountGroupByAccTypeAccGroup :one
SELECT id, company_id, report_type, account_type, account_group_name 
FROM accounting.chart_of_account_groups
WHERE company_id = $1 AND account_type = $2 AND account_group_name = $3
`

type GetChartOfAccountGroupByAccTypeAccGroupParams struct {
	CompanyID        string `db:"company_id"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

type GetChartOfAccountGroupByAccTypeAccGroupRow struct {
	ID               string `db:"id"`
	CompanyID        string `db:"company_id"`
	ReportType       string `db:"report_type"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

func (q *Queries) GetChartOfAccountGroupByAccTypeAccGroup(ctx context.Context, arg GetChartOfAccountGroupByAccTypeAccGroupParams) (GetChartOfAccountGroupByAccTypeAccGroupRow, error) {
	row := q.db.QueryRowContext(ctx, getChartOfAccountGroupByAccTypeAccGroup, arg.CompanyID, arg.AccountType, arg.AccountGroupName)
	var i GetChartOfAccountGroupByAccTypeAccGroupRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ReportType,
		&i.AccountType,
		&i.AccountGroupName,
	)
	return i, err
}

const getChartOfAccountGroups = `-- name: GetChartOfAccountGroups :many
SELECT id, company_id, report_type, account_type, account_group_name 
FROM accounting.chart_of_account_groups
WHERE company_id = $1
`

type GetChartOfAccountGroupsRow struct {
	ID               string `db:"id"`
	CompanyID        string `db:"company_id"`
	ReportType       string `db:"report_type"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

func (q *Queries) GetChartOfAccountGroups(ctx context.Context, companyID string) ([]GetChartOfAccountGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChartOfAccountGroups, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChartOfAccountGroupsRow
	for rows.Next() {
		var i GetChartOfAccountGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.ReportType,
			&i.AccountType,
			&i.AccountGroupName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyChartOfAccount = `-- name: GetCompanyChartOfAccount :one
SELECT id, company_id, currency_code, chart_of_account_group_id, account_code, account_name, bank_name, bank_account_number, bank_code, is_deleted, is_all_branches, created_at, updated_at
FROM accounting.company_chart_of_accounts
WHERE company_id = $1
`

func (q *Queries) GetCompanyChartOfAccount(ctx context.Context, companyID string) (AccountingCompanyChartOfAccount, error) {
	row := q.db.QueryRowContext(ctx, getCompanyChartOfAccount, companyID)
	var i AccountingCompanyChartOfAccount
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CurrencyCode,
		&i.ChartOfAccountGroupID,
		&i.AccountCode,
		&i.AccountName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.BankCode,
		&i.IsDeleted,
		&i.IsAllBranches,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompanyChartOfAccounts = `-- name: GetCompanyChartOfAccounts :many
SELECT a.id, a.company_id, a.currency_code, a.chart_of_account_group_id,
b.report_type, b.account_type, b.account_group_name, a.account_code, a.account_name,
a.bank_name, a.bank_account_number, a.bank_code, a.is_all_branches, a.is_deleted
FROM accounting.company_chart_of_accounts a
JOIN accounting.chart_of_account_groups b ON a.chart_of_account_group_id = b.id
WHERE a.company_id = $1
AND a.account_name LIKE $2
AND CASE WHEN $4::bool
THEN b.account_type = ANY($5::text[]) ELSE TRUE END
AND CASE WHEN $6::bool
THEN a.is_deleted = $3 ELSE TRUE END
`

type GetCompanyChartOfAccountsParams struct {
	CompanyID           string   `db:"company_id"`
	AccountName         string   `db:"account_name"`
	IsDeleted           bool     `db:"is_deleted"`
	IsFilterJournalType bool     `db:"is_filter_journal_type"`
	AccountTypes        []string `db:"account_types"`
	IsDeletedFilter     bool     `db:"is_deleted_filter"`
}

type GetCompanyChartOfAccountsRow struct {
	ID                    string `db:"id"`
	CompanyID             string `db:"company_id"`
	CurrencyCode          string `db:"currency_code"`
	ChartOfAccountGroupID string `db:"chart_of_account_group_id"`
	ReportType            string `db:"report_type"`
	AccountType           string `db:"account_type"`
	AccountGroupName      string `db:"account_group_name"`
	AccountCode           string `db:"account_code"`
	AccountName           string `db:"account_name"`
	BankName              string `db:"bank_name"`
	BankAccountNumber     string `db:"bank_account_number"`
	BankCode              string `db:"bank_code"`
	IsAllBranches         bool   `db:"is_all_branches"`
	IsDeleted             bool   `db:"is_deleted"`
}

func (q *Queries) GetCompanyChartOfAccounts(ctx context.Context, arg GetCompanyChartOfAccountsParams) ([]GetCompanyChartOfAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCompanyChartOfAccounts,
		arg.CompanyID,
		arg.AccountName,
		arg.IsDeleted,
		arg.IsFilterJournalType,
		pq.Array(arg.AccountTypes),
		arg.IsDeletedFilter,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCompanyChartOfAccountsRow
	for rows.Next() {
		var i GetCompanyChartOfAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.CurrencyCode,
			&i.ChartOfAccountGroupID,
			&i.ReportType,
			&i.AccountType,
			&i.AccountGroupName,
			&i.AccountCode,
			&i.AccountName,
			&i.BankName,
			&i.BankAccountNumber,
			&i.BankCode,
			&i.IsAllBranches,
			&i.IsDeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanySettingBank = `-- name: GetCompanySettingBank :one
SELECT id, company_id, chart_of_account_group_id, account_code, account_name,
bank_name, bank_account_number, bank_code, is_deleted
FROM accounting.company_chart_of_accounts
WHERE company_id = $1 
AND account_group = 'BANK'
ORDER BY created_at LIMIT 1
`

type GetCompanySettingBankRow struct {
	ID                    string `db:"id"`
	CompanyID             string `db:"company_id"`
	ChartOfAccountGroupID string `db:"chart_of_account_group_id"`
	AccountCode           string `db:"account_code"`
	AccountName           string `db:"account_name"`
	BankName              string `db:"bank_name"`
	BankAccountNumber     string `db:"bank_account_number"`
	BankCode              string `db:"bank_code"`
	IsDeleted             bool   `db:"is_deleted"`
}

func (q *Queries) GetCompanySettingBank(ctx context.Context, companyID string) (GetCompanySettingBankRow, error) {
	row := q.db.QueryRowContext(ctx, getCompanySettingBank, companyID)
	var i GetCompanySettingBankRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ChartOfAccountGroupID,
		&i.AccountCode,
		&i.AccountName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.BankCode,
		&i.IsDeleted,
	)
	return i, err
}

const getCompanySettingCash = `-- name: GetCompanySettingCash :one
SELECT id, company_id, chart_of_account_group_id, account_code, account_name,
bank_name, bank_account_number, bank_code, is_deleted
FROM accounting.company_chart_of_accounts
WHERE company_id = $1 
AND account_group = 'KAS'
ORDER BY created_at LIMIT 1
`

type GetCompanySettingCashRow struct {
	ID                    string `db:"id"`
	CompanyID             string `db:"company_id"`
	ChartOfAccountGroupID string `db:"chart_of_account_group_id"`
	AccountCode           string `db:"account_code"`
	AccountName           string `db:"account_name"`
	BankName              string `db:"bank_name"`
	BankAccountNumber     string `db:"bank_account_number"`
	BankCode              string `db:"bank_code"`
	IsDeleted             bool   `db:"is_deleted"`
}

func (q *Queries) GetCompanySettingCash(ctx context.Context, companyID string) (GetCompanySettingCashRow, error) {
	row := q.db.QueryRowContext(ctx, getCompanySettingCash, companyID)
	var i GetCompanySettingCashRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ChartOfAccountGroupID,
		&i.AccountCode,
		&i.AccountName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.BankCode,
		&i.IsDeleted,
	)
	return i, err
}

const getCompanySettingFiscalYear = `-- name: GetCompanySettingFiscalYear :one
SELECT company_id, start_period, end_period
FROM accounting.company_fiscal_years
WHERE company_id = $1
`

type GetCompanySettingFiscalYearRow struct {
	CompanyID   string    `db:"company_id"`
	StartPeriod time.Time `db:"start_period"`
	EndPeriod   time.Time `db:"end_period"`
}

func (q *Queries) GetCompanySettingFiscalYear(ctx context.Context, companyID string) (GetCompanySettingFiscalYearRow, error) {
	row := q.db.QueryRowContext(ctx, getCompanySettingFiscalYear, companyID)
	var i GetCompanySettingFiscalYearRow
	err := row.Scan(&i.CompanyID, &i.StartPeriod, &i.EndPeriod)
	return i, err
}

const insertCashTransaction = `-- name: InsertCashTransaction :one
INSERT INTO accounting.cash_transactions(id, company_id, branch_id, transaction_date, 
type, main_chart_of_account_id, contra_chart_of_account_id, 
amount, description)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, company_id, branch_id, transaction_date, type, main_chart_of_account_id, contra_chart_of_account_id, amount, description, created_at, updated_at
`

type InsertCashTransactionParams struct {
	ID                     string    `db:"id"`
	CompanyID              string    `db:"company_id"`
	BranchID               string    `db:"branch_id"`
	TransactionDate        time.Time `db:"transaction_date"`
	Type                   string    `db:"type"`
	MainChartOfAccountID   string    `db:"main_chart_of_account_id"`
	ContraChartOfAccountID string    `db:"contra_chart_of_account_id"`
	Amount                 int64     `db:"amount"`
	Description            string    `db:"description"`
}

func (q *Queries) InsertCashTransaction(ctx context.Context, arg InsertCashTransactionParams) (AccountingCashTransaction, error) {
	row := q.db.QueryRowContext(ctx, insertCashTransaction,
		arg.ID,
		arg.CompanyID,
		arg.BranchID,
		arg.TransactionDate,
		arg.Type,
		arg.MainChartOfAccountID,
		arg.ContraChartOfAccountID,
		arg.Amount,
		arg.Description,
	)
	var i AccountingCashTransaction
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.BranchID,
		&i.TransactionDate,
		&i.Type,
		&i.MainChartOfAccountID,
		&i.ContraChartOfAccountID,
		&i.Amount,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertChartOfAccountBranches = `-- name: InsertChartOfAccountBranches :exec
INSERT INTO accounting.chart_of_account_branches(chart_of_account_id, branch_id)
VALUES ($1, $2)
`

type InsertChartOfAccountBranchesParams struct {
	ChartOfAccountID string `db:"chart_of_account_id"`
	BranchID         string `db:"branch_id"`
}

func (q *Queries) InsertChartOfAccountBranches(ctx context.Context, arg InsertChartOfAccountBranchesParams) error {
	_, err := q.db.ExecContext(ctx, insertChartOfAccountBranches, arg.ChartOfAccountID, arg.BranchID)
	return err
}

const insertChartOfAccountGroup = `-- name: InsertChartOfAccountGroup :one
INSERT INTO accounting.chart_of_account_groups(id, company_id, 
report_type, account_type, account_group_name)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, company_id, report_type, account_type, account_group_name, created_at, updated_at
`

type InsertChartOfAccountGroupParams struct {
	ID               string `db:"id"`
	CompanyID        string `db:"company_id"`
	ReportType       string `db:"report_type"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

func (q *Queries) InsertChartOfAccountGroup(ctx context.Context, arg InsertChartOfAccountGroupParams) (AccountingChartOfAccountGroup, error) {
	row := q.db.QueryRowContext(ctx, insertChartOfAccountGroup,
		arg.ID,
		arg.CompanyID,
		arg.ReportType,
		arg.AccountType,
		arg.AccountGroupName,
	)
	var i AccountingChartOfAccountGroup
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ReportType,
		&i.AccountType,
		&i.AccountGroupName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertCompanyChartOfAccount = `-- name: InsertCompanyChartOfAccount :one
INSERT INTO accounting.company_chart_of_accounts(id, company_id, currency_code, 
chart_of_account_group_id, account_code, account_name, 
bank_name, bank_account_number, bank_code, is_all_branches)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, company_id, currency_code, chart_of_account_group_id, account_code, account_name, bank_name, bank_account_number, bank_code, is_deleted, is_all_branches, created_at, updated_at
`

type InsertCompanyChartOfAccountParams struct {
	ID                    string `db:"id"`
	CompanyID             string `db:"company_id"`
	CurrencyCode          string `db:"currency_code"`
	ChartOfAccountGroupID string `db:"chart_of_account_group_id"`
	AccountCode           string `db:"account_code"`
	AccountName           string `db:"account_name"`
	BankName              string `db:"bank_name"`
	BankAccountNumber     string `db:"bank_account_number"`
	BankCode              string `db:"bank_code"`
	IsAllBranches         bool   `db:"is_all_branches"`
}

func (q *Queries) InsertCompanyChartOfAccount(ctx context.Context, arg InsertCompanyChartOfAccountParams) (AccountingCompanyChartOfAccount, error) {
	row := q.db.QueryRowContext(ctx, insertCompanyChartOfAccount,
		arg.ID,
		arg.CompanyID,
		arg.CurrencyCode,
		arg.ChartOfAccountGroupID,
		arg.AccountCode,
		arg.AccountName,
		arg.BankName,
		arg.BankAccountNumber,
		arg.BankCode,
		arg.IsAllBranches,
	)
	var i AccountingCompanyChartOfAccount
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CurrencyCode,
		&i.ChartOfAccountGroupID,
		&i.AccountCode,
		&i.AccountName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.BankCode,
		&i.IsDeleted,
		&i.IsAllBranches,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertTransactionJournal = `-- name: InsertTransactionJournal :one
INSERT INTO accounting.transactions_journal(company_id, branch_id, transaction_id, 
transaction_date, transaction_reference , chart_of_account_id, 
amount, description)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING company_id, branch_id, transaction_id, transaction_date, transaction_reference, chart_of_account_id, amount, description, created_at
`

type InsertTransactionJournalParams struct {
	CompanyID            string    `db:"company_id"`
	BranchID             string    `db:"branch_id"`
	TransactionID        string    `db:"transaction_id"`
	TransactionDate      time.Time `db:"transaction_date"`
	TransactionReference string    `db:"transaction_reference"`
	ChartOfAccountID     string    `db:"chart_of_account_id"`
	Amount               int64     `db:"amount"`
	Description          string    `db:"description"`
}

func (q *Queries) InsertTransactionJournal(ctx context.Context, arg InsertTransactionJournalParams) (AccountingTransactionsJournal, error) {
	row := q.db.QueryRowContext(ctx, insertTransactionJournal,
		arg.CompanyID,
		arg.BranchID,
		arg.TransactionID,
		arg.TransactionDate,
		arg.TransactionReference,
		arg.ChartOfAccountID,
		arg.Amount,
		arg.Description,
	)
	var i AccountingTransactionsJournal
	err := row.Scan(
		&i.CompanyID,
		&i.BranchID,
		&i.TransactionID,
		&i.TransactionDate,
		&i.TransactionReference,
		&i.ChartOfAccountID,
		&i.Amount,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const updateChartOfAccountGroup = `-- name: UpdateChartOfAccountGroup :one
UPDATE accounting.chart_of_account_groups
SET 
    report_type = $2,
    account_type = $3,
    account_group_name = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, report_type, account_type, account_group_name, created_at, updated_at
`

type UpdateChartOfAccountGroupParams struct {
	ID               string `db:"id"`
	ReportType       string `db:"report_type"`
	AccountType      string `db:"account_type"`
	AccountGroupName string `db:"account_group_name"`
}

func (q *Queries) UpdateChartOfAccountGroup(ctx context.Context, arg UpdateChartOfAccountGroupParams) (AccountingChartOfAccountGroup, error) {
	row := q.db.QueryRowContext(ctx, updateChartOfAccountGroup,
		arg.ID,
		arg.ReportType,
		arg.AccountType,
		arg.AccountGroupName,
	)
	var i AccountingChartOfAccountGroup
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.ReportType,
		&i.AccountType,
		&i.AccountGroupName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCompanyChartOfAccount = `-- name: UpdateCompanyChartOfAccount :one
UPDATE accounting.company_chart_of_accounts
SET 
    currency_code = $2,
    chart_of_account_group_id = $3,
    account_code = $4,
    account_name = $5,
    bank_name = $6,
    bank_account_number = $7,
    bank_code = $8,
    is_all_branches = $9,
    is_deleted = $10,
    updated_at = NOW()
WHERE id = $1
RETURNING id, company_id, currency_code, chart_of_account_group_id, account_code, account_name, bank_name, bank_account_number, bank_code, is_deleted, is_all_branches, created_at, updated_at
`

type UpdateCompanyChartOfAccountParams struct {
	ID                    string `db:"id"`
	CurrencyCode          string `db:"currency_code"`
	ChartOfAccountGroupID string `db:"chart_of_account_group_id"`
	AccountCode           string `db:"account_code"`
	AccountName           string `db:"account_name"`
	BankName              string `db:"bank_name"`
	BankAccountNumber     string `db:"bank_account_number"`
	BankCode              string `db:"bank_code"`
	IsAllBranches         bool   `db:"is_all_branches"`
	IsDeleted             bool   `db:"is_deleted"`
}

func (q *Queries) UpdateCompanyChartOfAccount(ctx context.Context, arg UpdateCompanyChartOfAccountParams) (AccountingCompanyChartOfAccount, error) {
	row := q.db.QueryRowContext(ctx, updateCompanyChartOfAccount,
		arg.ID,
		arg.CurrencyCode,
		arg.ChartOfAccountGroupID,
		arg.AccountCode,
		arg.AccountName,
		arg.BankName,
		arg.BankAccountNumber,
		arg.BankCode,
		arg.IsAllBranches,
		arg.IsDeleted,
	)
	var i AccountingCompanyChartOfAccount
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CurrencyCode,
		&i.ChartOfAccountGroupID,
		&i.AccountCode,
		&i.AccountName,
		&i.BankName,
		&i.BankAccountNumber,
		&i.BankCode,
		&i.IsDeleted,
		&i.IsAllBranches,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertCompanyFiscalYear = `-- name: UpsertCompanyFiscalYear :one
INSERT INTO accounting.company_fiscal_years(company_id, start_period, end_period)
VALUES ($1, $2, $3)
ON CONFLICT (company_id)
DO UPDATE SET
    start_period = EXCLUDED.start_period,
    end_period = EXCLUDED.end_period,
    updated_at = NOW()
RETURNING company_id, start_period, end_period, created_at, updated_at
`

type UpsertCompanyFiscalYearParams struct {
	CompanyID   string    `db:"company_id"`
	StartPeriod time.Time `db:"start_period"`
	EndPeriod   time.Time `db:"end_period"`
}

func (q *Queries) UpsertCompanyFiscalYear(ctx context.Context, arg UpsertCompanyFiscalYearParams) (AccountingCompanyFiscalYear, error) {
	row := q.db.QueryRowContext(ctx, upsertCompanyFiscalYear, arg.CompanyID, arg.StartPeriod, arg.EndPeriod)
	var i AccountingCompanyFiscalYear
	err := row.Scan(
		&i.CompanyID,
		&i.StartPeriod,
		&i.EndPeriod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
